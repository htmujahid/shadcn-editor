{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "inline-image-plugin",
  "type": "registry:ui",
  "dependencies": [
    "@lexical/utils"
  ],
  "registryDependencies": [
    "button",
    "checkbox",
    "dialog",
    "input",
    "label",
    "select",
    "https://shadcn-editor.vercel.app/r/toolbar-plugin.json",
    "https://shadcn-editor.vercel.app/r/link-plugin.json"
  ],
  "files": [
    {
      "path": "registry/new-york-v4/editor/plugins/inline-image-plugin.tsx",
      "content": "\"use client\"\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nimport * as React from \"react\"\nimport { JSX, useEffect, useRef, useState } from \"react\"\n// import '../nodes/inline-image-node.css';\nimport { useLexicalComposerContext } from \"@lexical/react/LexicalComposerContext\"\nimport { $wrapNodeInElement, mergeRegister } from \"@lexical/utils\"\nimport {\n  $createParagraphNode,\n  $createRangeSelection,\n  $getSelection,\n  $insertNodes,\n  $isNodeSelection,\n  $isRootOrShadowRoot,\n  $setSelection,\n  COMMAND_PRIORITY_EDITOR,\n  COMMAND_PRIORITY_HIGH,\n  COMMAND_PRIORITY_LOW,\n  createCommand,\n  DRAGOVER_COMMAND,\n  DRAGSTART_COMMAND,\n  DROP_COMMAND,\n  LexicalCommand,\n  LexicalEditor,\n} from \"lexical\"\n\nimport type { Position } from \"@/registry/new-york-v4/editor/nodes/inline-image-node\"\nimport {\n  $createInlineImageNode,\n  $isInlineImageNode,\n  InlineImageNode,\n  InlineImagePayload,\n} from \"@/registry/new-york-v4/editor/nodes/inline-image-node\"\nimport { CAN_USE_DOM } from \"@/registry/new-york-v4/editor/shared/can-use-dom\"\nimport { Button } from \"@/registry/new-york-v4/ui/button\"\nimport { Checkbox } from \"@/registry/new-york-v4/ui/checkbox\"\nimport { Input } from \"@/registry/new-york-v4/ui/input\"\nimport { Label } from \"@/registry/new-york-v4/ui/label\"\nimport {\n  Select,\n  SelectContent,\n  SelectItem,\n  SelectTrigger,\n  SelectValue,\n} from \"@/registry/new-york-v4/ui/select\"\n\nexport type InsertInlineImagePayload = Readonly<InlineImagePayload>\n\nconst getDOMSelection = (targetWindow: Window | null): Selection | null =>\n  CAN_USE_DOM ? (targetWindow || window).getSelection() : null\n\nexport const INSERT_INLINE_IMAGE_COMMAND: LexicalCommand<InlineImagePayload> =\n  createCommand(\"INSERT_INLINE_IMAGE_COMMAND\")\n\nexport function InsertInlineImageDialog({\n  activeEditor,\n  onClose,\n}: {\n  activeEditor: LexicalEditor\n  onClose: () => void\n}): JSX.Element {\n  const hasModifier = useRef(false)\n\n  const [src, setSrc] = useState(\"\")\n  const [altText, setAltText] = useState(\"\")\n  const [showCaption, setShowCaption] = useState(false)\n  const [position, setPosition] = useState<Position>(\"left\")\n\n  const isDisabled = src === \"\"\n\n  const handleShowCaptionChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    setShowCaption(e.target.checked)\n  }\n\n  const handlePositionChange = (e: React.ChangeEvent<HTMLSelectElement>) => {\n    setPosition(e.target.value as Position)\n  }\n\n  const loadImage = (files: FileList | null) => {\n    const reader = new FileReader()\n    reader.onload = function () {\n      if (typeof reader.result === \"string\") {\n        setSrc(reader.result)\n      }\n      return \"\"\n    }\n    if (files !== null) {\n      reader.readAsDataURL(files[0])\n    }\n  }\n\n  useEffect(() => {\n    hasModifier.current = false\n    const handler = (e: KeyboardEvent) => {\n      hasModifier.current = e.altKey\n    }\n    document.addEventListener(\"keydown\", handler)\n    return () => {\n      document.removeEventListener(\"keydown\", handler)\n    }\n  }, [activeEditor])\n\n  const handleOnClick = () => {\n    const payload = { altText, position, showCaption, src }\n    activeEditor.dispatchCommand(INSERT_INLINE_IMAGE_COMMAND, payload)\n    onClose()\n  }\n\n  return (\n    <div className=\"grid gap-4 py-4\">\n      <div className=\"grid gap-2\">\n        <Label htmlFor=\"image\">Image Upload</Label>\n        <Input\n          id=\"image\"\n          type=\"file\"\n          onChange={(e) => loadImage(e.target.files)}\n          accept=\"image/*\"\n          data-test-id=\"image-modal-file-upload\"\n        />\n      </div>\n      <div className=\"grid gap-2\">\n        <Label htmlFor=\"alt-text\">Alt Text</Label>\n        <Input\n          id=\"alt-text\"\n          placeholder=\"Descriptive alternative text\"\n          onChange={(e) => setAltText(e.target.value)}\n          value={altText}\n          data-test-id=\"image-modal-alt-text-input\"\n        />\n      </div>\n      <div className=\"grid gap-2\">\n        <Label htmlFor=\"position\">Position</Label>\n        <Select\n          defaultValue=\"left\"\n          onValueChange={(value) => setPosition(value as Position)}\n        >\n          <SelectTrigger id=\"position\">\n            <SelectValue placeholder=\"Select position\" />\n          </SelectTrigger>\n          <SelectContent>\n            <SelectItem value=\"left\">Left</SelectItem>\n            <SelectItem value=\"right\">Right</SelectItem>\n            <SelectItem value=\"full\">Full Width</SelectItem>\n          </SelectContent>\n        </Select>\n      </div>\n      <div className=\"flex items-center space-x-2\">\n        <Checkbox\n          id=\"caption\"\n          checked={showCaption}\n          onCheckedChange={(checked) => setShowCaption(checked as boolean)}\n        />\n        <Label htmlFor=\"caption\">Show Caption</Label>\n      </div>\n      <Button\n        data-test-id=\"image-modal-file-upload-btn\"\n        disabled={isDisabled}\n        onClick={() => handleOnClick()}\n      >\n        Confirm\n      </Button>\n    </div>\n  )\n}\n\nexport function InlineImagePlugin(): JSX.Element | null {\n  const [editor] = useLexicalComposerContext()\n\n  useEffect(() => {\n    if (!editor.hasNodes([InlineImageNode])) {\n      throw new Error(\"ImagesPlugin: ImageNode not registered on editor\")\n    }\n\n    return mergeRegister(\n      editor.registerCommand<InsertInlineImagePayload>(\n        INSERT_INLINE_IMAGE_COMMAND,\n        (payload) => {\n          const imageNode = $createInlineImageNode(payload)\n          $insertNodes([imageNode])\n          if ($isRootOrShadowRoot(imageNode.getParentOrThrow())) {\n            $wrapNodeInElement(imageNode, $createParagraphNode).selectEnd()\n          }\n\n          return true\n        },\n        COMMAND_PRIORITY_EDITOR\n      ),\n      editor.registerCommand<DragEvent>(\n        DRAGSTART_COMMAND,\n        (event) => {\n          return $onDragStart(event)\n        },\n        COMMAND_PRIORITY_HIGH\n      ),\n      editor.registerCommand<DragEvent>(\n        DRAGOVER_COMMAND,\n        (event) => {\n          return $onDragover(event)\n        },\n        COMMAND_PRIORITY_LOW\n      ),\n      editor.registerCommand<DragEvent>(\n        DROP_COMMAND,\n        (event) => {\n          return $onDrop(event, editor)\n        },\n        COMMAND_PRIORITY_HIGH\n      )\n    )\n  }, [editor])\n\n  return null\n}\n\nfunction $onDragStart(event: DragEvent): boolean {\n  const node = $getImageNodeInSelection()\n  if (!node) {\n    return false\n  }\n  const dataTransfer = event.dataTransfer\n  if (!dataTransfer) {\n    return false\n  }\n  const TRANSPARENT_IMAGE =\n    \"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\"\n  const img = document.createElement(\"img\")\n  img.src = TRANSPARENT_IMAGE\n  dataTransfer.setData(\"text/plain\", \"_\")\n  dataTransfer.setDragImage(img, 0, 0)\n  dataTransfer.setData(\n    \"application/x-lexical-drag\",\n    JSON.stringify({\n      data: {\n        altText: node.__altText,\n        caption: node.__caption,\n        height: node.__height,\n        key: node.getKey(),\n        showCaption: node.__showCaption,\n        src: node.__src,\n        width: node.__width,\n      },\n      type: \"image\",\n    })\n  )\n\n  return true\n}\n\nfunction $onDragover(event: DragEvent): boolean {\n  const node = $getImageNodeInSelection()\n  if (!node) {\n    return false\n  }\n  if (!canDropImage(event)) {\n    event.preventDefault()\n  }\n  return true\n}\n\nfunction $onDrop(event: DragEvent, editor: LexicalEditor): boolean {\n  const node = $getImageNodeInSelection()\n  if (!node) {\n    return false\n  }\n  const data = getDragImageData(event)\n  if (!data) {\n    return false\n  }\n  event.preventDefault()\n  if (canDropImage(event)) {\n    const range = getDragSelection(event)\n    node.remove()\n    const rangeSelection = $createRangeSelection()\n    if (range !== null && range !== undefined) {\n      rangeSelection.applyDOMRange(range)\n    }\n    $setSelection(rangeSelection)\n    editor.dispatchCommand(INSERT_INLINE_IMAGE_COMMAND, data)\n  }\n  return true\n}\n\nfunction $getImageNodeInSelection(): InlineImageNode | null {\n  const selection = $getSelection()\n  if (!$isNodeSelection(selection)) {\n    return null\n  }\n  const nodes = selection.getNodes()\n  const node = nodes[0]\n  return $isInlineImageNode(node) ? node : null\n}\n\nfunction getDragImageData(event: DragEvent): null | InsertInlineImagePayload {\n  const dragData = event.dataTransfer?.getData(\"application/x-lexical-drag\")\n  if (!dragData) {\n    return null\n  }\n  const { type, data } = JSON.parse(dragData)\n  if (type !== \"image\") {\n    return null\n  }\n\n  return data\n}\n\ndeclare global {\n  interface DragEvent {\n    rangeOffset?: number\n    rangeParent?: Node\n  }\n}\n\nfunction canDropImage(event: DragEvent): boolean {\n  const target = event.target\n  return !!(\n    target &&\n    target instanceof HTMLElement &&\n    !target.closest(\"code, span.editor-image\") &&\n    target.parentElement &&\n    target.parentElement.closest(\"div.ContentEditable__root\")\n  )\n}\n\nfunction getDragSelection(event: DragEvent): Range | null | undefined {\n  let range\n  const target = event.target as null | Element | Document\n  const targetWindow =\n    target == null\n      ? null\n      : target.nodeType === 9\n        ? (target as Document).defaultView\n        : (target as Element).ownerDocument.defaultView\n  const domSelection = getDOMSelection(targetWindow)\n  if (document.caretRangeFromPoint) {\n    range = document.caretRangeFromPoint(event.clientX, event.clientY)\n  } else if (event.rangeParent && domSelection !== null) {\n    domSelection.collapse(event.rangeParent, event.rangeOffset || 0)\n    range = domSelection.getRangeAt(0)\n  } else {\n    throw Error(\"Cannot get the selection when dragging\")\n  }\n\n  return range\n}\n",
      "type": "registry:component",
      "target": "components/editor/plugins/inline-image-plugin.tsx"
    },
    {
      "path": "registry/new-york-v4/editor/nodes/inline-image-node.tsx",
      "content": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nimport * as React from \"react\"\nimport { JSX, Suspense } from \"react\"\nimport type {\n  DOMConversionMap,\n  DOMConversionOutput,\n  DOMExportOutput,\n  EditorConfig,\n  LexicalEditor,\n  LexicalNode,\n  NodeKey,\n  SerializedEditor,\n  SerializedLexicalNode,\n  Spread,\n} from \"lexical\"\nimport { $applyNodeReplacement, createEditor, DecoratorNode } from \"lexical\"\n\nconst InlineImageComponent = React.lazy(\n  () => import(\"../editor-ui/inline-image-component\")\n)\n\nexport type Position = \"left\" | \"right\" | \"full\" | undefined\n\nexport interface InlineImagePayload {\n  altText: string\n  caption?: LexicalEditor\n  height?: number\n  key?: NodeKey\n  showCaption?: boolean\n  src: string\n  width?: number\n  position?: Position\n}\n\nexport interface UpdateInlineImagePayload {\n  altText?: string\n  showCaption?: boolean\n  position?: Position\n}\n\nfunction $convertInlineImageElement(domNode: Node): null | DOMConversionOutput {\n  if (domNode instanceof HTMLImageElement) {\n    const { alt: altText, src, width, height } = domNode\n    const node = $createInlineImageNode({ altText, height, src, width })\n    return { node }\n  }\n  return null\n}\n\nexport type SerializedInlineImageNode = Spread<\n  {\n    altText: string\n    caption: SerializedEditor\n    height?: number\n    showCaption: boolean\n    src: string\n    width?: number\n    position?: Position\n  },\n  SerializedLexicalNode\n>\n\nexport class InlineImageNode extends DecoratorNode<JSX.Element> {\n  __src: string\n  __altText: string\n  __width: \"inherit\" | number\n  __height: \"inherit\" | number\n  __showCaption: boolean\n  __caption: LexicalEditor\n  __position: Position\n\n  static getType(): string {\n    return \"inline-image\"\n  }\n\n  static clone(node: InlineImageNode): InlineImageNode {\n    return new InlineImageNode(\n      node.__src,\n      node.__altText,\n      node.__position,\n      node.__width,\n      node.__height,\n      node.__showCaption,\n      node.__caption,\n      node.__key\n    )\n  }\n\n  static importJSON(\n    serializedNode: SerializedInlineImageNode\n  ): InlineImageNode {\n    const { altText, height, width, caption, src, showCaption, position } =\n      serializedNode\n    const node = $createInlineImageNode({\n      altText,\n      height,\n      position,\n      showCaption,\n      src,\n      width,\n    })\n    const nestedEditor = node.__caption\n    const editorState = nestedEditor.parseEditorState(caption.editorState)\n    if (!editorState.isEmpty()) {\n      nestedEditor.setEditorState(editorState)\n    }\n    return node\n  }\n\n  static importDOM(): DOMConversionMap | null {\n    return {\n      img: (node: Node) => ({\n        conversion: $convertInlineImageElement,\n        priority: 0,\n      }),\n    }\n  }\n\n  constructor(\n    src: string,\n    altText: string,\n    position: Position,\n    width?: \"inherit\" | number,\n    height?: \"inherit\" | number,\n    showCaption?: boolean,\n    caption?: LexicalEditor,\n    key?: NodeKey\n  ) {\n    super(key)\n    this.__src = src\n    this.__altText = altText\n    this.__width = width || \"inherit\"\n    this.__height = height || \"inherit\"\n    this.__showCaption = showCaption || false\n    this.__caption = caption || createEditor()\n    this.__position = position\n  }\n\n  exportDOM(): DOMExportOutput {\n    const element = document.createElement(\"img\")\n    element.setAttribute(\"src\", this.__src)\n    element.setAttribute(\"alt\", this.__altText)\n    element.setAttribute(\"width\", this.__width.toString())\n    element.setAttribute(\"height\", this.__height.toString())\n    return { element }\n  }\n\n  exportJSON(): SerializedInlineImageNode {\n    return {\n      altText: this.getAltText(),\n      caption: this.__caption.toJSON(),\n      height: this.__height === \"inherit\" ? 0 : this.__height,\n      position: this.__position,\n      showCaption: this.__showCaption,\n      src: this.getSrc(),\n      type: \"inline-image\",\n      version: 1,\n      width: this.__width === \"inherit\" ? 0 : this.__width,\n    }\n  }\n\n  getSrc(): string {\n    return this.__src\n  }\n\n  getAltText(): string {\n    return this.__altText\n  }\n\n  setAltText(altText: string): void {\n    const writable = this.getWritable()\n    writable.__altText = altText\n  }\n\n  setWidthAndHeight(\n    width: \"inherit\" | number,\n    height: \"inherit\" | number\n  ): void {\n    const writable = this.getWritable()\n    writable.__width = width\n    writable.__height = height\n  }\n\n  getShowCaption(): boolean {\n    return this.__showCaption\n  }\n\n  setShowCaption(showCaption: boolean): void {\n    const writable = this.getWritable()\n    writable.__showCaption = showCaption\n  }\n\n  getPosition(): Position {\n    return this.__position\n  }\n\n  setPosition(position: Position): void {\n    const writable = this.getWritable()\n    writable.__position = position\n  }\n\n  update(payload: UpdateInlineImagePayload): void {\n    const writable = this.getWritable()\n    const { altText, showCaption, position } = payload\n    if (altText !== undefined) {\n      writable.__altText = altText\n    }\n    if (showCaption !== undefined) {\n      writable.__showCaption = showCaption\n    }\n    if (position !== undefined) {\n      writable.__position = position\n    }\n  }\n\n  // View\n  getPositionClassName(): string {\n    switch (this.__position) {\n      case \"left\":\n        return \"float-left w-1/2\"\n      case \"right\":\n        return \"float-right w-1/2 \"\n      case \"full\":\n        return \"w-full\"\n      default:\n        return \"\"\n    }\n  }\n\n  createDOM(config: EditorConfig): HTMLElement {\n    const span = document.createElement(\"span\")\n    const className = `${config.theme.inlineImage} ${this.getPositionClassName()}`\n    if (className !== undefined) {\n      span.className = className\n    }\n    return span\n  }\n\n  updateDOM(\n    prevNode: InlineImageNode,\n    dom: HTMLElement,\n    config: EditorConfig\n  ): false {\n    const position = this.__position\n    if (position !== prevNode.__position) {\n      const className = `${config.theme.inlineImage} ${this.getPositionClassName()}`\n      if (className !== undefined) {\n        dom.className = className\n      }\n    }\n    return false\n  }\n\n  decorate(): JSX.Element {\n    return (\n      <Suspense fallback={null}>\n        <InlineImageComponent\n          src={this.__src}\n          altText={this.__altText}\n          width={this.__width}\n          height={this.__height}\n          nodeKey={this.getKey()}\n          showCaption={this.__showCaption}\n          caption={this.__caption}\n          position={this.__position}\n        />\n      </Suspense>\n    )\n  }\n}\n\nexport function $createInlineImageNode({\n  altText,\n  position,\n  height,\n  src,\n  width,\n  showCaption,\n  caption,\n  key,\n}: InlineImagePayload): InlineImageNode {\n  return $applyNodeReplacement(\n    new InlineImageNode(\n      src,\n      altText,\n      position,\n      width,\n      height,\n      showCaption,\n      caption,\n      key\n    )\n  )\n}\n\nexport function $isInlineImageNode(\n  node: LexicalNode | null | undefined\n): node is InlineImageNode {\n  return node instanceof InlineImageNode\n}\n",
      "type": "registry:component",
      "target": "components/editor/nodes/inline-image-node.tsx"
    },
    {
      "path": "registry/new-york-v4/editor/editor-ui/inline-image-component.tsx",
      "content": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nimport * as React from \"react\"\nimport { JSX, Suspense, useCallback, useEffect, useRef, useState } from \"react\"\nimport { AutoFocusPlugin } from \"@lexical/react/LexicalAutoFocusPlugin\"\nimport { useLexicalComposerContext } from \"@lexical/react/LexicalComposerContext\"\nimport { LexicalErrorBoundary } from \"@lexical/react/LexicalErrorBoundary\"\nimport { LexicalNestedComposer } from \"@lexical/react/LexicalNestedComposer\"\nimport { RichTextPlugin } from \"@lexical/react/LexicalRichTextPlugin\"\nimport { useLexicalEditable } from \"@lexical/react/useLexicalEditable\"\nimport { useLexicalNodeSelection } from \"@lexical/react/useLexicalNodeSelection\"\nimport { mergeRegister } from \"@lexical/utils\"\nimport type { BaseSelection, LexicalEditor, NodeKey } from \"lexical\"\nimport {\n  $getNodeByKey,\n  $getSelection,\n  $isNodeSelection,\n  $setSelection,\n  CLICK_COMMAND,\n  COMMAND_PRIORITY_LOW,\n  DRAGSTART_COMMAND,\n  KEY_BACKSPACE_COMMAND,\n  KEY_DELETE_COMMAND,\n  KEY_ENTER_COMMAND,\n  KEY_ESCAPE_COMMAND,\n  SELECTION_CHANGE_COMMAND,\n} from \"lexical\"\n\nimport { useEditorModal } from \"@/registry/new-york-v4/editor/editor-hooks/use-modal\"\nimport { ContentEditable } from \"@/registry/new-york-v4/editor/editor-ui/content-editable\"\nimport type { Position } from \"@/registry/new-york-v4/editor/nodes/inline-image-node\"\nimport {\n  $isInlineImageNode,\n  InlineImageNode,\n} from \"@/registry/new-york-v4/editor/nodes/inline-image-node\"\nimport { LinkPlugin } from \"@/registry/new-york-v4/editor/plugins/link-plugin\"\nimport { Button } from \"@/registry/new-york-v4/ui/button\"\nimport { Checkbox } from \"@/registry/new-york-v4/ui/checkbox\"\nimport { DialogFooter } from \"@/registry/new-york-v4/ui/dialog\"\nimport { Input } from \"@/registry/new-york-v4/ui/input\"\nimport { Label } from \"@/registry/new-york-v4/ui/label\"\nimport {\n  Select,\n  SelectContent,\n  SelectItem,\n  SelectTrigger,\n  SelectValue,\n} from \"@/registry/new-york-v4/ui/select\"\n\nconst imageCache = new Set()\n\nfunction useSuspenseImage(src: string) {\n  if (!imageCache.has(src)) {\n    throw new Promise((resolve) => {\n      const img = new Image()\n      img.src = src\n      img.onload = () => {\n        imageCache.add(src)\n        resolve(null)\n      }\n    })\n  }\n}\n\nfunction LazyImage({\n  altText,\n  className,\n  imageRef,\n  src,\n  width,\n  height,\n  position,\n}: {\n  altText: string\n  className: string | null\n  height: \"inherit\" | number\n  imageRef: { current: null | HTMLImageElement }\n  src: string\n  width: \"inherit\" | number\n  position: Position\n}): JSX.Element {\n  useSuspenseImage(src)\n  return (\n    <img\n      className={className || undefined}\n      src={src}\n      alt={altText}\n      ref={imageRef}\n      data-position={position}\n      style={{\n        display: \"block\",\n        height,\n        width,\n      }}\n      draggable=\"false\"\n    />\n  )\n}\n\nexport function UpdateInlineImageDialog({\n  activeEditor,\n  nodeKey,\n  onClose,\n}: {\n  activeEditor: LexicalEditor\n  nodeKey: NodeKey\n  onClose: () => void\n}): JSX.Element {\n  const editorState = activeEditor.getEditorState()\n  const node = editorState.read(() => $getNodeByKey(nodeKey) as InlineImageNode)\n  const [altText, setAltText] = useState(node.getAltText())\n  const [showCaption, setShowCaption] = useState(node.getShowCaption())\n  const [position, setPosition] = useState<Position>(node.getPosition())\n\n  const handleShowCaptionChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    setShowCaption(e.target.checked)\n  }\n\n  const handlePositionChange = (e: React.ChangeEvent<HTMLSelectElement>) => {\n    setPosition(e.target.value as Position)\n  }\n\n  const handleOnConfirm = () => {\n    const payload = { altText, position, showCaption }\n    if (node) {\n      activeEditor.update(() => {\n        node.update(payload)\n      })\n    }\n    onClose()\n  }\n\n  return (\n    <div className=\"space-y-4\">\n      <div className=\"space-y-2\">\n        <Label htmlFor=\"alt-text\">Alt Text</Label>\n        <Input\n          id=\"alt-text\"\n          placeholder=\"Descriptive alternative text\"\n          onChange={(e) => setAltText(e.target.value)}\n          value={altText}\n          data-test-id=\"image-modal-alt-text-input\"\n        />\n      </div>\n\n      <div className=\"space-y-2\">\n        <Label htmlFor=\"position-select\">Position</Label>\n        <Select\n          value={position}\n          onValueChange={(value) => setPosition(value as Position)}\n        >\n          <SelectTrigger id=\"position-select\">\n            <SelectValue placeholder=\"Select position\" />\n          </SelectTrigger>\n          <SelectContent>\n            <SelectItem value=\"left\">Left</SelectItem>\n            <SelectItem value=\"right\">Right</SelectItem>\n            <SelectItem value=\"full\">Full Width</SelectItem>\n          </SelectContent>\n        </Select>\n      </div>\n\n      <div className=\"flex items-center space-x-2\">\n        <Checkbox\n          id=\"caption\"\n          checked={showCaption}\n          onCheckedChange={(checked) => setShowCaption(checked as boolean)}\n        />\n        <Label htmlFor=\"caption\">Show Caption</Label>\n      </div>\n\n      <DialogFooter>\n        <Button\n          data-test-id=\"image-modal-file-upload-btn\"\n          onClick={handleOnConfirm}\n        >\n          Confirm\n        </Button>\n      </DialogFooter>\n    </div>\n  )\n}\n\nexport default function InlineImageComponent({\n  src,\n  altText,\n  nodeKey,\n  width,\n  height,\n  showCaption,\n  caption,\n  position,\n}: {\n  altText: string\n  caption: LexicalEditor\n  height: \"inherit\" | number\n  nodeKey: NodeKey\n  showCaption: boolean\n  src: string\n  width: \"inherit\" | number\n  position: Position\n}): JSX.Element {\n  const [modal, showModal] = useEditorModal()\n  const imageRef = useRef<null | HTMLImageElement>(null)\n  const buttonRef = useRef<HTMLButtonElement | null>(null)\n  const [isSelected, setSelected, clearSelection] =\n    useLexicalNodeSelection(nodeKey)\n  const [editor] = useLexicalComposerContext()\n  const [selection, setSelection] = useState<BaseSelection | null>(null)\n  const activeEditorRef = useRef<LexicalEditor | null>(null)\n  const isEditable = useLexicalEditable()\n\n  const $onDelete = useCallback(\n    (payload: KeyboardEvent) => {\n      const deleteSelection = $getSelection()\n      if (isSelected && $isNodeSelection(deleteSelection)) {\n        const event: KeyboardEvent = payload\n        event.preventDefault()\n        if (isSelected && $isNodeSelection(deleteSelection)) {\n          editor.update(() => {\n            deleteSelection.getNodes().forEach((node) => {\n              if ($isInlineImageNode(node)) {\n                node.remove()\n              }\n            })\n          })\n        }\n      }\n      return false\n    },\n    [editor, isSelected]\n  )\n\n  const $onEnter = useCallback(\n    (event: KeyboardEvent) => {\n      const latestSelection = $getSelection()\n      const buttonElem = buttonRef.current\n      if (\n        isSelected &&\n        $isNodeSelection(latestSelection) &&\n        latestSelection.getNodes().length === 1\n      ) {\n        if (showCaption) {\n          // Move focus into nested editor\n          $setSelection(null)\n          event.preventDefault()\n          caption.focus()\n          return true\n        } else if (\n          buttonElem !== null &&\n          buttonElem !== document.activeElement\n        ) {\n          event.preventDefault()\n          buttonElem.focus()\n          return true\n        }\n      }\n      return false\n    },\n    [caption, isSelected, showCaption]\n  )\n\n  const $onEscape = useCallback(\n    (event: KeyboardEvent) => {\n      if (\n        activeEditorRef.current === caption ||\n        buttonRef.current === event.target\n      ) {\n        $setSelection(null)\n        editor.update(() => {\n          setSelected(true)\n          const parentRootElement = editor.getRootElement()\n          if (parentRootElement !== null) {\n            parentRootElement.focus()\n          }\n        })\n        return true\n      }\n      return false\n    },\n    [caption, editor, setSelected]\n  )\n\n  useEffect(() => {\n    let isMounted = true\n    const unregister = mergeRegister(\n      editor.registerUpdateListener(({ editorState }) => {\n        if (isMounted) {\n          setSelection(editorState.read(() => $getSelection()))\n        }\n      }),\n      editor.registerCommand(\n        SELECTION_CHANGE_COMMAND,\n        (_, activeEditor) => {\n          activeEditorRef.current = activeEditor\n          return false\n        },\n        COMMAND_PRIORITY_LOW\n      ),\n      editor.registerCommand<MouseEvent>(\n        CLICK_COMMAND,\n        (payload) => {\n          const event = payload\n          if (event.target === imageRef.current) {\n            if (event.shiftKey) {\n              setSelected(!isSelected)\n            } else {\n              clearSelection()\n              setSelected(true)\n            }\n            return true\n          }\n\n          return false\n        },\n        COMMAND_PRIORITY_LOW\n      ),\n      editor.registerCommand(\n        DRAGSTART_COMMAND,\n        (event) => {\n          if (event.target === imageRef.current) {\n            // TODO This is just a temporary workaround for FF to behave like other browsers.\n            // Ideally, this handles drag & drop too (and all browsers).\n            event.preventDefault()\n            return true\n          }\n          return false\n        },\n        COMMAND_PRIORITY_LOW\n      ),\n      editor.registerCommand(\n        KEY_DELETE_COMMAND,\n        $onDelete,\n        COMMAND_PRIORITY_LOW\n      ),\n      editor.registerCommand(\n        KEY_BACKSPACE_COMMAND,\n        $onDelete,\n        COMMAND_PRIORITY_LOW\n      ),\n      editor.registerCommand(KEY_ENTER_COMMAND, $onEnter, COMMAND_PRIORITY_LOW),\n      editor.registerCommand(\n        KEY_ESCAPE_COMMAND,\n        $onEscape,\n        COMMAND_PRIORITY_LOW\n      )\n    )\n    return () => {\n      isMounted = false\n      unregister()\n    }\n  }, [\n    clearSelection,\n    editor,\n    isSelected,\n    nodeKey,\n    $onDelete,\n    $onEnter,\n    $onEscape,\n    setSelected,\n  ])\n\n  const draggable = isSelected && $isNodeSelection(selection)\n  const isFocused = isSelected && isEditable\n  return (\n    <Suspense fallback={null}>\n      <>\n        <span draggable={draggable}>\n          {isEditable && (\n            <Button\n              className=\"image-edit-button absolute top-1 right-1\"\n              variant=\"outline\"\n              ref={buttonRef}\n              onClick={() => {\n                showModal(\"Update Inline Image\", (onClose) => (\n                  <UpdateInlineImageDialog\n                    activeEditor={editor}\n                    nodeKey={nodeKey}\n                    onClose={onClose}\n                  />\n                ))\n              }}\n            >\n              Edit\n            </Button>\n          )}\n          <LazyImage\n            className={`max-w-full cursor-default ${\n              isFocused\n                ? `${\n                    $isNodeSelection(selection)\n                      ? \"draggable cursor-grab active:cursor-grabbing\"\n                      : \"\"\n                  } focused ring-primary ring-2 ring-offset-2`\n                : null\n            }`}\n            src={src}\n            altText={altText}\n            imageRef={imageRef}\n            width={width}\n            height={height}\n            position={position}\n          />\n        </span>\n        {showCaption && (\n          <div className=\"image-caption-container absolute right-0 bottom-1 left-0 m-0 block min-w-[100px] overflow-hidden border-t bg-white/90 p-0\">\n            <LexicalNestedComposer initialEditor={caption}>\n              <AutoFocusPlugin />\n              <LinkPlugin />\n              <RichTextPlugin\n                contentEditable={\n                  <ContentEditable\n                    placeholder=\"Enter a caption...\"\n                    className=\"ImageNode__contentEditable user-select-text word-break-break-word caret-primary relative block min-h-5 w-[calc(100%-20px)] cursor-text resize-none border-0 p-2.5 text-sm whitespace-pre-wrap outline-none\"\n                    placeholderClassName=\"ImageNode__placeholder text-sm text-muted-foreground overflow-hidden absolute top-2.5 left-2.5 pointer-events-none text-ellipsis user-select-none whitespace-nowrap inline-block\"\n                  />\n                }\n                ErrorBoundary={LexicalErrorBoundary}\n              />\n            </LexicalNestedComposer>\n          </div>\n        )}\n      </>\n      {modal}\n    </Suspense>\n  )\n}\n",
      "type": "registry:component",
      "target": "components/editor/editor-ui/inline-image-component.tsx"
    },
    {
      "path": "registry/new-york-v4/editor/editor-hooks/use-modal.tsx",
      "content": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nimport { JSX, useCallback, useMemo, useState } from \"react\"\nimport * as React from \"react\"\n\nimport {\n  Dialog,\n  DialogContent,\n  DialogHeader,\n  DialogTitle,\n} from \"@/registry/new-york-v4/ui/dialog\"\n\nexport function useEditorModal(): [\n  JSX.Element | null,\n  (title: string, showModal: (onClose: () => void) => JSX.Element) => void,\n] {\n  const [modalContent, setModalContent] = useState<null | {\n    closeOnClickOutside: boolean\n    content: JSX.Element\n    title: string\n  }>(null)\n\n  const onClose = useCallback(() => {\n    setModalContent(null)\n  }, [])\n\n  const modal = useMemo(() => {\n    if (modalContent === null) {\n      return null\n    }\n    const { title, content } = modalContent\n    return (\n      <Dialog open={true} onOpenChange={onClose}>\n        <DialogContent>\n          <DialogHeader>\n            <DialogTitle>{title}</DialogTitle>\n          </DialogHeader>\n          {content}\n        </DialogContent>\n      </Dialog>\n    )\n  }, [modalContent, onClose])\n\n  const showModal = useCallback(\n    (\n      title: string,\n      getContent: (onClose: () => void) => JSX.Element,\n      closeOnClickOutside = false\n    ) => {\n      setModalContent({\n        closeOnClickOutside,\n        content: getContent(onClose),\n        title,\n      })\n    },\n    [onClose]\n  )\n\n  return [modal, showModal]\n}\n",
      "type": "registry:component",
      "target": "components/editor/editor-hooks/use-modal.tsx"
    },
    {
      "path": "registry/new-york-v4/editor/editor-ui/content-editable.tsx",
      "content": "import { JSX } from \"react\"\nimport { ContentEditable as LexicalContentEditable } from \"@lexical/react/LexicalContentEditable\"\n\ntype Props = {\n  placeholder: string\n  className?: string\n  placeholderClassName?: string\n}\n\nexport function ContentEditable({\n  placeholder,\n  className,\n  placeholderClassName,\n}: Props): JSX.Element {\n  return (\n    <LexicalContentEditable\n      className={\n        className ??\n        `ContentEditable__root relative block min-h-72 min-h-full overflow-auto px-8 py-4 focus:outline-none`\n      }\n      aria-placeholder={placeholder}\n      placeholder={\n        <div\n          className={\n            placeholderClassName ??\n            `text-muted-foreground pointer-events-none absolute top-0 left-0 overflow-hidden px-8 py-[18px] text-ellipsis select-none`\n          }\n        >\n          {placeholder}\n        </div>\n      }\n    />\n  )\n}\n",
      "type": "registry:component",
      "target": "components/editor/editor-ui/content-editable.tsx"
    },
    {
      "path": "registry/new-york-v4/editor/shared/can-use-dom.ts",
      "content": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nexport const CAN_USE_DOM: boolean =\n  typeof window !== \"undefined\" &&\n  typeof window.document !== \"undefined\" &&\n  typeof window.document.createElement !== \"undefined\"\n",
      "type": "registry:component",
      "target": "components/editor/shared/can-use-dom.ts"
    },
    {
      "path": "registry/new-york-v4/editor/plugins/toolbar/block-insert/insert-inline-image.tsx",
      "content": "\"use client\"\n\nimport { FileImageIcon } from \"lucide-react\"\n\nimport { useToolbarContext } from \"@/registry/new-york-v4/editor/context/toolbar-context\"\nimport { InsertInlineImageDialog } from \"@/registry/new-york-v4/editor/plugins/inline-image-plugin\"\nimport { SelectItem } from \"@/registry/new-york-v4/ui/select\"\n\nexport function InsertInlineImage() {\n  const { activeEditor, showModal } = useToolbarContext()\n\n  return (\n    <SelectItem\n      value=\"inline-image\"\n      onPointerUp={() =>\n        showModal(\"Insert Inline Image\", (onClose) => (\n          <InsertInlineImageDialog\n            activeEditor={activeEditor}\n            onClose={onClose}\n          />\n        ))\n      }\n      className=\"\"\n    >\n      <div className=\"flex items-center gap-1\">\n        <FileImageIcon className=\"size-4\" />\n        <span>Inline Image</span>\n      </div>\n    </SelectItem>\n  )\n}\n",
      "type": "registry:component",
      "target": "components/editor/plugins/toolbar/block-insert/insert-inline-image.tsx"
    }
  ]
}