{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "context-menu-plugin",
  "type": "registry:ui",
  "dependencies": [
    "@lexical/link"
  ],
  "registryDependencies": [
    "command",
    "popover",
    "https://shadcn-editor.vercel.app/r/rich-text-editor-plugin.json"
  ],
  "files": [
    {
      "path": "registry/new-york-v4/editor/plugins/context-menu-plugin.tsx",
      "content": "\"use client\"\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nimport { JSX, useCallback, useMemo } from \"react\"\nimport * as React from \"react\"\nimport dynamic from \"next/dynamic\"\nimport { $isLinkNode, TOGGLE_LINK_COMMAND } from \"@lexical/link\"\nimport { useLexicalComposerContext } from \"@lexical/react/LexicalComposerContext\"\nimport { MenuOption } from \"@lexical/react/LexicalContextMenuPlugin\"\nimport { PopoverPortal } from \"@radix-ui/react-popover\"\nimport {\n  $getNearestNodeFromDOMNode,\n  $getSelection,\n  $isRangeSelection,\n  COPY_COMMAND,\n  CUT_COMMAND,\n  PASTE_COMMAND,\n  type LexicalNode,\n} from \"lexical\"\n\nimport {\n  Command,\n  CommandItem,\n  CommandList,\n} from \"@/registry/new-york-v4/ui/command\"\nimport {\n  Popover,\n  PopoverContent,\n  PopoverTrigger,\n} from \"@/registry/new-york-v4/ui/popover\"\n\nconst LexicalContextMenuPlugin = dynamic(\n  () => import(\"./default/lexical-context-menu-plugin\"),\n  { ssr: false }\n)\n\nexport class ContextMenuOption extends MenuOption {\n  title: string\n  onSelect: (targetNode: LexicalNode | null) => void\n  constructor(\n    title: string,\n    options: {\n      onSelect: (targetNode: LexicalNode | null) => void\n    }\n  ) {\n    super(title)\n    this.title = title\n    this.onSelect = options.onSelect.bind(this)\n  }\n}\n\nexport function ContextMenuPlugin(): JSX.Element {\n  const [editor] = useLexicalComposerContext()\n  const [isOpen, setIsOpen] = React.useState(false)\n\n  const defaultOptions = useMemo(() => {\n    return [\n      new ContextMenuOption(`Copy`, {\n        onSelect: (_node) => {\n          editor.dispatchCommand(COPY_COMMAND, null)\n        },\n      }),\n      new ContextMenuOption(`Cut`, {\n        onSelect: (_node) => {\n          editor.dispatchCommand(CUT_COMMAND, null)\n        },\n      }),\n      new ContextMenuOption(`Paste`, {\n        onSelect: (_node) => {\n          navigator.clipboard.read().then(async function (...args) {\n            const data = new DataTransfer()\n\n            const items = await navigator.clipboard.read()\n            const item = items[0]\n\n            const permission = await navigator.permissions.query({\n              // @ts-expect-error These types are incorrect.\n              name: \"clipboard-read\",\n            })\n            if (permission.state === \"denied\") {\n              alert(\"Not allowed to paste from clipboard.\")\n              return\n            }\n\n            for (const type of item.types) {\n              const dataString = await (await item.getType(type)).text()\n              data.setData(type, dataString)\n            }\n\n            const event = new ClipboardEvent(\"paste\", {\n              clipboardData: data,\n            })\n\n            editor.dispatchCommand(PASTE_COMMAND, event)\n          })\n        },\n      }),\n      new ContextMenuOption(`Paste as Plain Text`, {\n        onSelect: (_node) => {\n          navigator.clipboard.read().then(async function (...args) {\n            const permission = await navigator.permissions.query({\n              // @ts-expect-error These types are incorrect.\n              name: \"clipboard-read\",\n            })\n\n            if (permission.state === \"denied\") {\n              alert(\"Not allowed to paste from clipboard.\")\n              return\n            }\n\n            const data = new DataTransfer()\n            const items = await navigator.clipboard.readText()\n            data.setData(\"text/plain\", items)\n\n            const event = new ClipboardEvent(\"paste\", {\n              clipboardData: data,\n            })\n            editor.dispatchCommand(PASTE_COMMAND, event)\n          })\n        },\n      }),\n      new ContextMenuOption(`Delete Node`, {\n        onSelect: (_node) => {\n          const selection = $getSelection()\n          if ($isRangeSelection(selection)) {\n            const currentNode = selection.anchor.getNode()\n            const ancestorNodeWithRootAsParent = currentNode.getParents().at(-2)\n\n            ancestorNodeWithRootAsParent?.remove()\n          }\n        },\n      }),\n    ]\n  }, [editor])\n\n  const [options, setOptions] = React.useState(defaultOptions)\n\n  const onSelectOption = useCallback(\n    (\n      selectedOption: ContextMenuOption,\n      targetNode: LexicalNode | null,\n      closeMenu: () => void\n    ) => {\n      editor.update(() => {\n        selectedOption.onSelect(targetNode)\n        closeMenu()\n      })\n    },\n    [editor]\n  )\n\n  const onWillOpen = (event: MouseEvent) => {\n    let newOptions = defaultOptions\n    setIsOpen(true)\n    editor.update(() => {\n      const node = $getNearestNodeFromDOMNode(event.target as Element)\n      if (node) {\n        const parent = node.getParent()\n        if ($isLinkNode(parent)) {\n          newOptions = [\n            new ContextMenuOption(`Remove Link`, {\n              onSelect: (_node) => {\n                editor.dispatchCommand(TOGGLE_LINK_COMMAND, null)\n              },\n            }),\n            ...defaultOptions,\n          ]\n        }\n      }\n    })\n    setOptions(newOptions)\n  }\n\n  return (\n    <LexicalContextMenuPlugin\n      options={options}\n      onSelectOption={(option, targetNode) => {\n        onSelectOption(option as ContextMenuOption, targetNode, () => {\n          setIsOpen(false)\n        })\n      }}\n      onWillOpen={onWillOpen}\n      onOpen={() => {\n        setIsOpen(true)\n      }}\n      onClose={() => {\n        setIsOpen(false)\n      }}\n      menuRenderFn={(\n        anchorElementRef,\n        { options: _options, selectOptionAndCleanUp },\n        { setMenuRef }\n      ) => {\n        return anchorElementRef.current ? (\n          <Popover open={isOpen} onOpenChange={setIsOpen}>\n            <PopoverPortal container={anchorElementRef.current}>\n              <div>\n                <PopoverTrigger\n                  ref={setMenuRef}\n                  style={{\n                    marginLeft: anchorElementRef.current?.style.width,\n                    userSelect: \"none\",\n                  }}\n                />\n                <PopoverContent className=\"w-[200px] p-1\">\n                  <Command>\n                    <CommandList>\n                      {options.map((option) => (\n                        <CommandItem\n                          key={option.key}\n                          onSelect={() => {\n                            selectOptionAndCleanUp(option)\n                          }}\n                        >\n                          {option.title}\n                        </CommandItem>\n                      ))}\n                    </CommandList>\n                  </Command>\n                </PopoverContent>\n              </div>\n            </PopoverPortal>\n          </Popover>\n        ) : null\n      }}\n    />\n  )\n}\n",
      "type": "registry:component",
      "target": "components/editor/plugins/context-menu-plugin.tsx"
    },
    {
      "path": "registry/new-york-v4/editor/plugins/default/lexical-context-menu-plugin.tsx",
      "content": "import { LexicalContextMenuPlugin } from \"@lexical/react/LexicalContextMenuPlugin\"\n\nexport default LexicalContextMenuPlugin\n",
      "type": "registry:component",
      "target": "components/editor/plugins/default/lexical-context-menu-plugin.tsx"
    }
  ]
}