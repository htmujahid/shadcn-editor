{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "table-plugin",
  "type": "registry:ui",
  "dependencies": [
    "lodash-es",
    "react-colorful",
    "@lexical/table",
    "@lexical/utils",
    "@lexical/markdown"
  ],
  "registryDependencies": [
    "button",
    "command",
    "dialog",
    "input",
    "label",
    "popover",
    "select",
    "https://shadcn-editor.vercel.app/r/toolbar-plugin.json"
  ],
  "files": [
    {
      "path": "registry/new-york-v4/editor/plugins/table-plugin.tsx",
      "content": "\"use client\"\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nimport {\n  createContext,\n  JSX,\n  useContext,\n  useEffect,\n  useMemo,\n  useState,\n} from \"react\"\nimport * as React from \"react\"\nimport { useLexicalComposerContext } from \"@lexical/react/LexicalComposerContext\"\nimport {\n  $createTableNodeWithDimensions,\n  INSERT_TABLE_COMMAND,\n  TableNode,\n} from \"@lexical/table\"\nimport {\n  $insertNodes,\n  COMMAND_PRIORITY_EDITOR,\n  createCommand,\n  EditorThemeClasses,\n  Klass,\n  LexicalCommand,\n  LexicalEditor,\n  LexicalNode,\n} from \"lexical\"\n\nimport { invariant } from \"@/registry/new-york-v4/editor/shared/invariant\"\nimport { Button } from \"@/registry/new-york-v4/ui/button\"\nimport { DialogFooter } from \"@/registry/new-york-v4/ui/dialog\"\nimport { Input } from \"@/registry/new-york-v4/ui/input\"\nimport { Label } from \"@/registry/new-york-v4/ui/label\"\n\nexport type InsertTableCommandPayload = Readonly<{\n  columns: string\n  rows: string\n  includeHeaders?: boolean\n}>\n\nexport type CellContextShape = {\n  cellEditorConfig: null | CellEditorConfig\n  cellEditorPlugins: null | JSX.Element | Array<JSX.Element>\n  set: (\n    cellEditorConfig: null | CellEditorConfig,\n    cellEditorPlugins: null | JSX.Element | Array<JSX.Element>\n  ) => void\n}\n\nexport type CellEditorConfig = Readonly<{\n  namespace: string\n  nodes?: ReadonlyArray<Klass<LexicalNode>>\n  onError: (error: Error, editor: LexicalEditor) => void\n  readOnly?: boolean\n  theme?: EditorThemeClasses\n}>\n\nexport const INSERT_NEW_TABLE_COMMAND: LexicalCommand<InsertTableCommandPayload> =\n  createCommand(\"INSERT_NEW_TABLE_COMMAND\")\n\nexport const CellContext = createContext<CellContextShape>({\n  cellEditorConfig: null,\n  cellEditorPlugins: null,\n  set: () => {\n    // Empty\n  },\n})\n\nexport function TableContext({ children }: { children: JSX.Element }) {\n  const [contextValue, setContextValue] = useState<{\n    cellEditorConfig: null | CellEditorConfig\n    cellEditorPlugins: null | JSX.Element | Array<JSX.Element>\n  }>({\n    cellEditorConfig: null,\n    cellEditorPlugins: null,\n  })\n  return (\n    <CellContext.Provider\n      value={useMemo(\n        () => ({\n          cellEditorConfig: contextValue.cellEditorConfig,\n          cellEditorPlugins: contextValue.cellEditorPlugins,\n          set: (cellEditorConfig, cellEditorPlugins) => {\n            setContextValue({ cellEditorConfig, cellEditorPlugins })\n          },\n        }),\n        [contextValue.cellEditorConfig, contextValue.cellEditorPlugins]\n      )}\n    >\n      {children}\n    </CellContext.Provider>\n  )\n}\n\nexport function InsertTableDialog({\n  activeEditor,\n  onClose,\n}: {\n  activeEditor: LexicalEditor\n  onClose: () => void\n}): JSX.Element {\n  const [rows, setRows] = useState(\"5\")\n  const [columns, setColumns] = useState(\"5\")\n  const [isDisabled, setIsDisabled] = useState(true)\n\n  useEffect(() => {\n    const row = Number(rows)\n    const column = Number(columns)\n    if (row && row > 0 && row <= 500 && column && column > 0 && column <= 50) {\n      setIsDisabled(false)\n    } else {\n      setIsDisabled(true)\n    }\n  }, [rows, columns])\n\n  const onClick = () => {\n    activeEditor.dispatchCommand(INSERT_TABLE_COMMAND, {\n      columns,\n      rows,\n    })\n\n    onClose()\n  }\n\n  return (\n    <>\n      <div className=\"grid gap-4\">\n        <div className=\"grid gap-2\">\n          <Label htmlFor=\"rows\">Number of rows</Label>\n          <Input\n            id=\"rows\"\n            placeholder={\"# of rows (1-500)\"}\n            onChange={(e) => setRows(e.target.value)}\n            value={rows}\n            data-test-id=\"table-modal-rows\"\n            type=\"number\"\n          />\n        </div>\n        <div className=\"grid gap-2\">\n          <Label htmlFor=\"columns\">Number of columns</Label>\n          <Input\n            id=\"columns\"\n            placeholder={\"# of columns (1-50)\"}\n            onChange={(e) => setColumns(e.target.value)}\n            value={columns}\n            data-test-id=\"table-modal-columns\"\n            type=\"number\"\n          />\n        </div>\n      </div>\n      <DialogFooter data-test-id=\"table-model-confirm-insert\">\n        <Button disabled={isDisabled} onClick={onClick}>\n          Confirm\n        </Button>\n      </DialogFooter>\n    </>\n  )\n}\n\nexport function TablePlugin({\n  cellEditorConfig,\n  children,\n}: {\n  cellEditorConfig: CellEditorConfig\n  children: JSX.Element | Array<JSX.Element>\n}): JSX.Element | null {\n  const [editor] = useLexicalComposerContext()\n  const cellContext = useContext(CellContext)\n\n  useEffect(() => {\n    if (!editor.hasNodes([TableNode])) {\n      invariant(false, \"TablePlugin: TableNode is not registered on editor\")\n    }\n\n    cellContext.set(cellEditorConfig, children)\n\n    return editor.registerCommand<InsertTableCommandPayload>(\n      INSERT_NEW_TABLE_COMMAND,\n      ({ columns, rows, includeHeaders }) => {\n        const tableNode = $createTableNodeWithDimensions(\n          Number(rows),\n          Number(columns),\n          includeHeaders\n        )\n        $insertNodes([tableNode])\n        return true\n      },\n      COMMAND_PRIORITY_EDITOR\n    )\n  }, [cellContext, cellEditorConfig, children, editor])\n\n  return null\n}\n",
      "type": "registry:component",
      "target": "components/editor/plugins/table-plugin.tsx"
    },
    {
      "path": "registry/new-york-v4/editor/plugins/table-action-menu-plugin.tsx",
      "content": "\"use client\"\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nimport * as React from \"react\"\nimport {\n  JSX,\n  ReactPortal,\n  useCallback,\n  useEffect,\n  useRef,\n  useState,\n} from \"react\"\nimport { useLexicalComposerContext } from \"@lexical/react/LexicalComposerContext\"\nimport { useLexicalEditable } from \"@lexical/react/useLexicalEditable\"\nimport {\n  $deleteTableColumn__EXPERIMENTAL,\n  $deleteTableRow__EXPERIMENTAL,\n  $getNodeTriplet,\n  $getTableCellNodeFromLexicalNode,\n  $getTableColumnIndexFromTableCellNode,\n  $getTableNodeFromLexicalNodeOrThrow,\n  $getTableRowIndexFromTableCellNode,\n  $insertTableColumn__EXPERIMENTAL,\n  $insertTableRow__EXPERIMENTAL,\n  $isTableCellNode,\n  $isTableRowNode,\n  $isTableSelection,\n  $unmergeCell,\n  getTableObserverFromTableElement,\n  HTMLTableElementWithWithTableSelectionState,\n  TableCellHeaderStates,\n  TableCellNode,\n  TableRowNode,\n  TableSelection,\n} from \"@lexical/table\"\nimport type { ElementNode, LexicalEditor } from \"lexical\"\nimport {\n  $createParagraphNode,\n  $getRoot,\n  $getSelection,\n  $isElementNode,\n  $isParagraphNode,\n  $isRangeSelection,\n  $isTextNode,\n} from \"lexical\"\nimport { ChevronDownIcon, PaintBucketIcon } from \"lucide-react\"\nimport { createPortal } from \"react-dom\"\n\nimport { useEditorModal } from \"@/registry/new-york-v4/editor/editor-hooks/use-modal\"\nimport ColorPicker from \"@/registry/new-york-v4/editor/editor-ui/colorpicker\"\nimport {\n  Command,\n  CommandGroup,\n  CommandItem,\n  CommandList,\n  CommandSeparator,\n} from \"@/registry/new-york-v4/ui/command\"\nimport {\n  Popover,\n  PopoverContent,\n  PopoverTrigger,\n} from \"@/registry/new-york-v4/ui/popover\"\n\nfunction computeSelectionCount(selection: TableSelection): {\n  columns: number\n  rows: number\n} {\n  const selectionShape = selection.getShape()\n  return {\n    columns: selectionShape.toX - selectionShape.fromX + 1,\n    rows: selectionShape.toY - selectionShape.fromY + 1,\n  }\n}\n\nfunction $canUnmerge(): boolean {\n  const selection = $getSelection()\n  if (\n    ($isRangeSelection(selection) && !selection.isCollapsed()) ||\n    ($isTableSelection(selection) && !selection.anchor.is(selection.focus)) ||\n    (!$isRangeSelection(selection) && !$isTableSelection(selection))\n  ) {\n    return false\n  }\n  const [cell] = $getNodeTriplet(selection.anchor)\n  return cell.__colSpan > 1 || cell.__rowSpan > 1\n}\n\nfunction $cellContainsEmptyParagraph(cell: TableCellNode): boolean {\n  if (cell.getChildrenSize() !== 1) {\n    return false\n  }\n  const firstChild = cell.getFirstChildOrThrow()\n  if (!$isParagraphNode(firstChild) || !firstChild.isEmpty()) {\n    return false\n  }\n  return true\n}\n\nfunction $selectLastDescendant(node: ElementNode): void {\n  const lastDescendant = node.getLastDescendant()\n  if ($isTextNode(lastDescendant)) {\n    lastDescendant.select()\n  } else if ($isElementNode(lastDescendant)) {\n    lastDescendant.selectEnd()\n  } else if (lastDescendant !== null) {\n    lastDescendant.selectNext()\n  }\n}\n\nfunction currentCellBackgroundColor(editor: LexicalEditor): null | string {\n  return editor.getEditorState().read(() => {\n    const selection = $getSelection()\n    if ($isRangeSelection(selection) || $isTableSelection(selection)) {\n      const [cell] = $getNodeTriplet(selection.anchor)\n      if ($isTableCellNode(cell)) {\n        return cell.getBackgroundColor()\n      }\n    }\n    return null\n  })\n}\n\ntype TableCellActionMenuProps = Readonly<{\n  contextRef: { current: null | HTMLElement }\n  onClose: () => void\n  setIsMenuOpen: (isOpen: boolean) => void\n  tableCellNode: TableCellNode\n  cellMerge: boolean\n}>\n\nfunction TableActionMenu({\n  onClose,\n  tableCellNode: _tableCellNode,\n  setIsMenuOpen,\n  contextRef,\n  cellMerge,\n}: TableCellActionMenuProps) {\n  const [editor] = useLexicalComposerContext()\n  const dropDownRef = useRef<HTMLDivElement | null>(null)\n  const [tableCellNode, updateTableCellNode] = useState(_tableCellNode)\n  const [selectionCounts, updateSelectionCounts] = useState({\n    columns: 1,\n    rows: 1,\n  })\n  const [modal, showModal] = useEditorModal()\n  const [canMergeCells, setCanMergeCells] = useState(false)\n  const [canUnmergeCell, setCanUnmergeCell] = useState(false)\n  const [backgroundColor, setBackgroundColor] = useState(\n    () => currentCellBackgroundColor(editor) || \"\"\n  )\n\n  useEffect(() => {\n    return editor.registerMutationListener(\n      TableCellNode,\n      (nodeMutations) => {\n        const nodeUpdated =\n          nodeMutations.get(tableCellNode.getKey()) === \"updated\"\n\n        if (nodeUpdated) {\n          editor.getEditorState().read(() => {\n            updateTableCellNode(tableCellNode.getLatest())\n          })\n          setBackgroundColor(currentCellBackgroundColor(editor) || \"\")\n        }\n      },\n      { skipInitialization: true }\n    )\n  }, [editor, tableCellNode])\n\n  useEffect(() => {\n    editor.getEditorState().read(() => {\n      const selection = $getSelection()\n      // Merge cells\n      if ($isTableSelection(selection)) {\n        const currentSelectionCounts = computeSelectionCount(selection)\n        updateSelectionCounts(computeSelectionCount(selection))\n        setCanMergeCells(\n          currentSelectionCounts.columns > 1 || currentSelectionCounts.rows > 1\n        )\n      }\n      // Unmerge cell\n      setCanUnmergeCell($canUnmerge())\n    })\n  }, [editor])\n\n  useEffect(() => {\n    const menuButtonElement = contextRef.current\n    const dropDownElement = dropDownRef.current\n    const rootElement = editor.getRootElement()\n\n    if (\n      menuButtonElement != null &&\n      dropDownElement != null &&\n      rootElement != null\n    ) {\n      const rootEleRect = rootElement.getBoundingClientRect()\n      const menuButtonRect = menuButtonElement.getBoundingClientRect()\n      dropDownElement.style.opacity = \"1\"\n      const dropDownElementRect = dropDownElement.getBoundingClientRect()\n      const margin = 5\n      let leftPosition = menuButtonRect.right + margin\n      if (\n        leftPosition + dropDownElementRect.width > window.innerWidth ||\n        leftPosition + dropDownElementRect.width > rootEleRect.right\n      ) {\n        const position =\n          menuButtonRect.left - dropDownElementRect.width - margin\n        leftPosition = (position < 0 ? margin : position) + window.pageXOffset\n      }\n      dropDownElement.style.left = `${leftPosition + window.pageXOffset}px`\n\n      let topPosition = menuButtonRect.top\n      if (topPosition + dropDownElementRect.height > window.innerHeight) {\n        const position = menuButtonRect.bottom - dropDownElementRect.height\n        topPosition = (position < 0 ? margin : position) + window.pageYOffset\n      }\n      dropDownElement.style.top = `${topPosition + +window.pageYOffset}px`\n    }\n  }, [contextRef, dropDownRef, editor])\n\n  useEffect(() => {\n    function handleClickOutside(event: MouseEvent) {\n      if (\n        dropDownRef.current != null &&\n        contextRef.current != null &&\n        !dropDownRef.current.contains(event.target as Node) &&\n        !contextRef.current.contains(event.target as Node)\n      ) {\n        setIsMenuOpen(false)\n      }\n    }\n\n    window.addEventListener(\"click\", handleClickOutside)\n\n    return () => window.removeEventListener(\"click\", handleClickOutside)\n  }, [setIsMenuOpen, contextRef])\n\n  const clearTableSelection = useCallback(() => {\n    editor.update(() => {\n      if (tableCellNode.isAttached()) {\n        const tableNode = $getTableNodeFromLexicalNodeOrThrow(tableCellNode)\n        const tableElement = editor.getElementByKey(\n          tableNode.getKey()\n        ) as HTMLTableElementWithWithTableSelectionState\n\n        if (!tableElement) {\n          throw new Error(\"Expected to find tableElement in DOM\")\n        }\n\n        const tableObserver = getTableObserverFromTableElement(tableElement)\n        if (tableObserver !== null) {\n          tableObserver.$clearHighlight()\n        }\n\n        tableNode.markDirty()\n        updateTableCellNode(tableCellNode.getLatest())\n      }\n\n      const rootNode = $getRoot()\n      rootNode.selectStart()\n    })\n  }, [editor, tableCellNode])\n\n  const mergeTableCellsAtSelection = () => {\n    editor.update(() => {\n      const selection = $getSelection()\n      if ($isTableSelection(selection)) {\n        const { columns, rows } = computeSelectionCount(selection)\n        const nodes = selection.getNodes()\n        let firstCell: null | TableCellNode = null\n        for (let i = 0; i < nodes.length; i++) {\n          const node = nodes[i]\n          if ($isTableCellNode(node)) {\n            if (firstCell === null) {\n              node.setColSpan(columns).setRowSpan(rows)\n              firstCell = node\n              const isEmpty = $cellContainsEmptyParagraph(node)\n              let firstChild\n              if (\n                isEmpty &&\n                $isParagraphNode((firstChild = node.getFirstChild()))\n              ) {\n                firstChild.remove()\n              }\n            } else if ($isTableCellNode(firstCell)) {\n              const isEmpty = $cellContainsEmptyParagraph(node)\n              if (!isEmpty) {\n                firstCell.append(...node.getChildren())\n              }\n              node.remove()\n            }\n          }\n        }\n        if (firstCell !== null) {\n          if (firstCell.getChildrenSize() === 0) {\n            firstCell.append($createParagraphNode())\n          }\n          $selectLastDescendant(firstCell)\n        }\n        onClose()\n      }\n    })\n  }\n\n  const unmergeTableCellsAtSelection = () => {\n    editor.update(() => {\n      $unmergeCell()\n    })\n  }\n\n  const insertTableRowAtSelection = useCallback(\n    (shouldInsertAfter: boolean) => {\n      editor.update(() => {\n        $insertTableRow__EXPERIMENTAL(shouldInsertAfter)\n        onClose()\n      })\n    },\n    [editor, onClose]\n  )\n\n  const insertTableColumnAtSelection = useCallback(\n    (shouldInsertAfter: boolean) => {\n      editor.update(() => {\n        for (let i = 0; i < selectionCounts.columns; i++) {\n          $insertTableColumn__EXPERIMENTAL(shouldInsertAfter)\n        }\n        onClose()\n      })\n    },\n    [editor, onClose, selectionCounts.columns]\n  )\n\n  const deleteTableRowAtSelection = useCallback(() => {\n    editor.update(() => {\n      $deleteTableRow__EXPERIMENTAL()\n      onClose()\n    })\n  }, [editor, onClose])\n\n  const deleteTableAtSelection = useCallback(() => {\n    editor.update(() => {\n      const tableNode = $getTableNodeFromLexicalNodeOrThrow(tableCellNode)\n      tableNode.remove()\n\n      clearTableSelection()\n      onClose()\n    })\n  }, [editor, tableCellNode, clearTableSelection, onClose])\n\n  const deleteTableColumnAtSelection = useCallback(() => {\n    editor.update(() => {\n      $deleteTableColumn__EXPERIMENTAL()\n      onClose()\n    })\n  }, [editor, onClose])\n\n  const toggleTableRowIsHeader = useCallback(() => {\n    editor.update(() => {\n      const tableNode = $getTableNodeFromLexicalNodeOrThrow(tableCellNode)\n\n      const tableRowIndex = $getTableRowIndexFromTableCellNode(tableCellNode)\n\n      const tableRows = tableNode.getChildren()\n\n      if (tableRowIndex >= tableRows.length || tableRowIndex < 0) {\n        throw new Error(\"Expected table cell to be inside of table row.\")\n      }\n\n      const tableRow = tableRows[tableRowIndex]\n\n      if (!$isTableRowNode(tableRow)) {\n        throw new Error(\"Expected table row\")\n      }\n\n      const newStyle =\n        tableCellNode.getHeaderStyles() ^ TableCellHeaderStates.ROW\n      tableRow.getChildren().forEach((tableCell) => {\n        if (!$isTableCellNode(tableCell)) {\n          throw new Error(\"Expected table cell\")\n        }\n\n        tableCell.setHeaderStyles(newStyle, TableCellHeaderStates.ROW)\n      })\n\n      clearTableSelection()\n      onClose()\n    })\n  }, [editor, tableCellNode, clearTableSelection, onClose])\n\n  const toggleTableColumnIsHeader = useCallback(() => {\n    editor.update(() => {\n      const tableNode = $getTableNodeFromLexicalNodeOrThrow(tableCellNode)\n\n      const tableColumnIndex =\n        $getTableColumnIndexFromTableCellNode(tableCellNode)\n\n      const tableRows = tableNode.getChildren<TableRowNode>()\n      const maxRowsLength = Math.max(\n        ...tableRows.map((row) => row.getChildren().length)\n      )\n\n      if (tableColumnIndex >= maxRowsLength || tableColumnIndex < 0) {\n        throw new Error(\"Expected table cell to be inside of table row.\")\n      }\n\n      const newStyle =\n        tableCellNode.getHeaderStyles() ^ TableCellHeaderStates.COLUMN\n      for (let r = 0; r < tableRows.length; r++) {\n        const tableRow = tableRows[r]\n\n        if (!$isTableRowNode(tableRow)) {\n          throw new Error(\"Expected table row\")\n        }\n\n        const tableCells = tableRow.getChildren()\n        if (tableColumnIndex >= tableCells.length) {\n          // if cell is outside of bounds for the current row (for example various merge cell cases) we shouldn't highlight it\n          continue\n        }\n\n        const tableCell = tableCells[tableColumnIndex]\n\n        if (!$isTableCellNode(tableCell)) {\n          throw new Error(\"Expected table cell\")\n        }\n\n        tableCell.setHeaderStyles(newStyle, TableCellHeaderStates.COLUMN)\n      }\n      clearTableSelection()\n      onClose()\n    })\n  }, [editor, tableCellNode, clearTableSelection, onClose])\n\n  const toggleRowStriping = useCallback(() => {\n    editor.update(() => {\n      if (tableCellNode.isAttached()) {\n        const tableNode = $getTableNodeFromLexicalNodeOrThrow(tableCellNode)\n        if (tableNode) {\n          tableNode.setRowStriping(!tableNode.getRowStriping())\n        }\n      }\n      clearTableSelection()\n      onClose()\n    })\n  }, [editor, tableCellNode, clearTableSelection, onClose])\n\n  const handleCellBackgroundColor = useCallback(\n    (value: string) => {\n      editor.update(() => {\n        const selection = $getSelection()\n        if ($isRangeSelection(selection) || $isTableSelection(selection)) {\n          const [cell] = $getNodeTriplet(selection.anchor)\n          if ($isTableCellNode(cell)) {\n            cell.setBackgroundColor(value)\n          }\n\n          if ($isTableSelection(selection)) {\n            const nodes = selection.getNodes()\n\n            for (let i = 0; i < nodes.length; i++) {\n              const node = nodes[i]\n              if ($isTableCellNode(node)) {\n                node.setBackgroundColor(value)\n              }\n            }\n          }\n        }\n      })\n    },\n    [editor]\n  )\n\n  let mergeCellButton: null | JSX.Element = null\n  if (cellMerge) {\n    if (canMergeCells) {\n      mergeCellButton = (\n        <CommandItem onSelect={() => mergeTableCellsAtSelection()}>\n          Merge cells\n        </CommandItem>\n      )\n    } else if (canUnmergeCell) {\n      mergeCellButton = (\n        <CommandItem onSelect={() => unmergeTableCellsAtSelection()}>\n          Unmerge cells\n        </CommandItem>\n      )\n    }\n  }\n\n  return (\n    <>\n      {modal}\n      <Command>\n        <CommandList>\n          <CommandGroup>\n            {mergeCellButton}\n            <CommandItem className=\"flex justify-between\">\n              Background color\n              <ColorPicker\n                color={backgroundColor}\n                onChange={handleCellBackgroundColor}\n                icon={<PaintBucketIcon className=\"size-4\" />}\n              />\n            </CommandItem>\n            <CommandItem onSelect={() => toggleRowStriping()}>\n              Toggle row striping\n            </CommandItem>\n            <CommandSeparator />\n            <CommandItem onSelect={() => insertTableRowAtSelection(false)}>\n              Insert{\" \"}\n              {selectionCounts.rows === 1\n                ? \"row\"\n                : `${selectionCounts.rows} rows`}{\" \"}\n              above\n            </CommandItem>\n            <CommandItem onSelect={() => insertTableRowAtSelection(true)}>\n              Insert{\" \"}\n              {selectionCounts.rows === 1\n                ? \"row\"\n                : `${selectionCounts.rows} rows`}{\" \"}\n              below\n            </CommandItem>\n            <CommandSeparator />\n            <CommandItem onSelect={() => insertTableColumnAtSelection(false)}>\n              Insert{\" \"}\n              {selectionCounts.columns === 1\n                ? \"column\"\n                : `${selectionCounts.columns} columns`}{\" \"}\n              left\n            </CommandItem>\n            <CommandItem onSelect={() => insertTableColumnAtSelection(true)}>\n              Insert{\" \"}\n              {selectionCounts.columns === 1\n                ? \"column\"\n                : `${selectionCounts.columns} columns`}{\" \"}\n              right\n            </CommandItem>\n            <CommandSeparator />\n            <CommandItem onSelect={() => deleteTableColumnAtSelection()}>\n              Delete column\n            </CommandItem>\n            <CommandItem onSelect={() => deleteTableRowAtSelection()}>\n              Delete row\n            </CommandItem>\n            <CommandItem onSelect={() => deleteTableAtSelection()}>\n              Delete table\n            </CommandItem>\n            <CommandSeparator />\n            <CommandItem onSelect={() => toggleTableRowIsHeader()}>\n              {(tableCellNode.__headerState & TableCellHeaderStates.ROW) ===\n              TableCellHeaderStates.ROW\n                ? \"Remove\"\n                : \"Add\"}{\" \"}\n              row header\n            </CommandItem>\n            <CommandItem onSelect={() => toggleTableColumnIsHeader()}>\n              {(tableCellNode.__headerState & TableCellHeaderStates.COLUMN) ===\n              TableCellHeaderStates.COLUMN\n                ? \"Remove\"\n                : \"Add\"}{\" \"}\n              column header\n            </CommandItem>\n          </CommandGroup>\n        </CommandList>\n      </Command>\n    </>\n  )\n}\n\nfunction TableCellActionMenuContainer({\n  anchorElem,\n  cellMerge,\n}: {\n  anchorElem: HTMLElement\n  cellMerge: boolean\n}): JSX.Element {\n  const [editor] = useLexicalComposerContext()\n\n  const menuButtonRef = useRef(null)\n  const menuRootRef = useRef(null)\n  const [isMenuOpen, setIsMenuOpen] = useState(false)\n\n  const [tableCellNode, setTableMenuCellNode] = useState<TableCellNode | null>(\n    null\n  )\n\n  const $moveMenu = useCallback(() => {\n    const menu = menuButtonRef.current\n    const selection = $getSelection()\n    const nativeSelection = window.getSelection()\n    const activeElement = document.activeElement\n\n    if (selection == null || menu == null) {\n      setTableMenuCellNode(null)\n      return\n    }\n\n    const rootElement = editor.getRootElement()\n\n    if (\n      $isRangeSelection(selection) &&\n      rootElement !== null &&\n      nativeSelection !== null &&\n      rootElement.contains(nativeSelection.anchorNode)\n    ) {\n      const tableCellNodeFromSelection = $getTableCellNodeFromLexicalNode(\n        selection.anchor.getNode()\n      )\n\n      if (tableCellNodeFromSelection == null) {\n        setTableMenuCellNode(null)\n        return\n      }\n\n      const tableCellParentNodeDOM = editor.getElementByKey(\n        tableCellNodeFromSelection.getKey()\n      )\n\n      if (tableCellParentNodeDOM == null) {\n        setTableMenuCellNode(null)\n        return\n      }\n\n      setTableMenuCellNode(tableCellNodeFromSelection)\n    } else if (!activeElement) {\n      setTableMenuCellNode(null)\n    }\n  }, [editor])\n\n  useEffect(() => {\n    return editor.registerUpdateListener(() => {\n      editor.getEditorState().read(() => {\n        $moveMenu()\n      })\n    })\n  })\n\n  useEffect(() => {\n    const menuButtonDOM = menuButtonRef.current as HTMLButtonElement | null\n\n    if (menuButtonDOM != null && tableCellNode != null) {\n      const tableCellNodeDOM = editor.getElementByKey(tableCellNode.getKey())\n\n      if (tableCellNodeDOM != null) {\n        const tableCellRect = tableCellNodeDOM.getBoundingClientRect()\n        const menuRect = menuButtonDOM.getBoundingClientRect()\n        const anchorRect = anchorElem.getBoundingClientRect()\n\n        const top = tableCellRect.top - anchorRect.top + 4\n        const left = tableCellRect.right - menuRect.width - 10 - anchorRect.left\n\n        menuButtonDOM.style.opacity = \"1\"\n        menuButtonDOM.style.transform = `translate(${left}px, ${top}px)`\n      } else {\n        menuButtonDOM.style.opacity = \"0\"\n        menuButtonDOM.style.transform = \"translate(-10000px, -10000px)\"\n      }\n    }\n  }, [menuButtonRef, tableCellNode, editor, anchorElem])\n\n  const prevTableCellDOM = useRef(tableCellNode)\n\n  useEffect(() => {\n    if (prevTableCellDOM.current !== tableCellNode) {\n      setIsMenuOpen(false)\n    }\n\n    prevTableCellDOM.current = tableCellNode\n  }, [prevTableCellDOM, tableCellNode])\n\n  return (\n    <div\n      className=\"table-cell-action-button-container absolute top-0 will-change-transform\"\n      ref={menuButtonRef}\n    >\n      {tableCellNode != null && (\n        <Popover open={isMenuOpen} onOpenChange={setIsMenuOpen}>\n          <PopoverTrigger asChild>\n            <button\n              type=\"button\"\n              className=\"relative flex inline-block cursor-pointer items-center justify-center bg-none\"\n              onClick={(e) => {\n                e.stopPropagation()\n                setIsMenuOpen(!isMenuOpen)\n              }}\n              ref={menuRootRef}\n            >\n              <ChevronDownIcon className=\"h-4 w-4\" />\n            </button>\n          </PopoverTrigger>\n          <PopoverContent className=\"w-[200px] p-0\">\n            <TableActionMenu\n              contextRef={menuRootRef}\n              setIsMenuOpen={setIsMenuOpen}\n              onClose={() => setIsMenuOpen(false)}\n              tableCellNode={tableCellNode}\n              cellMerge={cellMerge}\n            />\n          </PopoverContent>\n        </Popover>\n      )}\n    </div>\n  )\n}\n\nexport function TableActionMenuPlugin({\n  anchorElem,\n  cellMerge = false,\n}: {\n  anchorElem: HTMLDivElement | null\n  cellMerge?: boolean\n}): null | ReactPortal {\n  const isEditable = useLexicalEditable()\n\n  if (!anchorElem) {\n    return null\n  }\n\n  return createPortal(\n    isEditable ? (\n      <TableCellActionMenuContainer\n        anchorElem={anchorElem}\n        cellMerge={cellMerge}\n      />\n    ) : null,\n    anchorElem\n  )\n}\n",
      "type": "registry:component",
      "target": "components/editor/plugins/table-action-menu-plugin.tsx"
    },
    {
      "path": "registry/new-york-v4/editor/plugins/table-cell-resizer-plugin.tsx",
      "content": "\"use client\"\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nimport * as React from \"react\"\nimport {\n  JSX,\n  MouseEventHandler,\n  useCallback,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n} from \"react\"\nimport { useLexicalComposerContext } from \"@lexical/react/LexicalComposerContext\"\nimport { useLexicalEditable } from \"@lexical/react/useLexicalEditable\"\nimport type { TableCellNode, TableDOMCell, TableMapType } from \"@lexical/table\"\nimport {\n  $computeTableMapSkipCellCheck,\n  $getTableNodeFromLexicalNodeOrThrow,\n  $getTableRowIndexFromTableCellNode,\n  $isTableCellNode,\n  $isTableRowNode,\n  getDOMCellFromTarget,\n  TableNode,\n} from \"@lexical/table\"\nimport { calculateZoomLevel } from \"@lexical/utils\"\nimport type { LexicalEditor } from \"lexical\"\nimport { $getNearestNodeFromDOMNode } from \"lexical\"\nimport { createPortal } from \"react-dom\"\n\ntype MousePosition = {\n  x: number\n  y: number\n}\n\ntype MouseDraggingDirection = \"right\" | \"bottom\"\n\nconst MIN_ROW_HEIGHT = 33\nconst MIN_COLUMN_WIDTH = 92\n\nfunction TableCellResizer({ editor }: { editor: LexicalEditor }): JSX.Element {\n  const targetRef = useRef<HTMLElement | null>(null)\n  const resizerRef = useRef<HTMLDivElement | null>(null)\n  const tableRectRef = useRef<ClientRect | null>(null)\n\n  const mouseStartPosRef = useRef<MousePosition | null>(null)\n  const [mouseCurrentPos, updateMouseCurrentPos] =\n    useState<MousePosition | null>(null)\n\n  const [activeCell, updateActiveCell] = useState<TableDOMCell | null>(null)\n  const [isMouseDown, updateIsMouseDown] = useState<boolean>(false)\n  const [draggingDirection, updateDraggingDirection] =\n    useState<MouseDraggingDirection | null>(null)\n\n  const resetState = useCallback(() => {\n    updateActiveCell(null)\n    targetRef.current = null\n    updateDraggingDirection(null)\n    mouseStartPosRef.current = null\n    tableRectRef.current = null\n  }, [])\n\n  const isMouseDownOnEvent = (event: MouseEvent) => {\n    return (event.buttons & 1) === 1\n  }\n\n  useEffect(() => {\n    return editor.registerNodeTransform(TableNode, (tableNode) => {\n      if (tableNode.getColWidths()) {\n        return tableNode\n      }\n\n      const numColumns = tableNode.getColumnCount()\n      const columnWidth = MIN_COLUMN_WIDTH\n\n      tableNode.setColWidths(Array(numColumns).fill(columnWidth))\n      return tableNode\n    })\n  }, [editor])\n\n  useEffect(() => {\n    const onMouseMove = (event: MouseEvent) => {\n      setTimeout(() => {\n        const target = event.target\n\n        if (draggingDirection) {\n          updateMouseCurrentPos({\n            x: event.clientX,\n            y: event.clientY,\n          })\n          return\n        }\n        updateIsMouseDown(isMouseDownOnEvent(event))\n        if (resizerRef.current && resizerRef.current.contains(target as Node)) {\n          return\n        }\n\n        if (targetRef.current !== target) {\n          targetRef.current = target as HTMLElement\n          const cell = getDOMCellFromTarget(target as HTMLElement)\n\n          if (cell && activeCell !== cell) {\n            editor.update(() => {\n              const tableCellNode = $getNearestNodeFromDOMNode(cell.elem)\n              if (!tableCellNode) {\n                throw new Error(\"TableCellResizer: Table cell node not found.\")\n              }\n\n              const tableNode =\n                $getTableNodeFromLexicalNodeOrThrow(tableCellNode)\n              const tableElement = editor.getElementByKey(tableNode.getKey())\n\n              if (!tableElement) {\n                throw new Error(\"TableCellResizer: Table element not found.\")\n              }\n\n              targetRef.current = target as HTMLElement\n              tableRectRef.current = tableElement.getBoundingClientRect()\n              updateActiveCell(cell)\n            })\n          } else if (cell == null) {\n            resetState()\n          }\n        }\n      }, 0)\n    }\n\n    const onMouseDown = (event: MouseEvent) => {\n      setTimeout(() => {\n        updateIsMouseDown(true)\n      }, 0)\n    }\n\n    const onMouseUp = (event: MouseEvent) => {\n      setTimeout(() => {\n        updateIsMouseDown(false)\n      }, 0)\n    }\n\n    const removeRootListener = editor.registerRootListener(\n      (rootElement, prevRootElement) => {\n        prevRootElement?.removeEventListener(\"mousemove\", onMouseMove)\n        prevRootElement?.removeEventListener(\"mousedown\", onMouseDown)\n        prevRootElement?.removeEventListener(\"mouseup\", onMouseUp)\n        rootElement?.addEventListener(\"mousemove\", onMouseMove)\n        rootElement?.addEventListener(\"mousedown\", onMouseDown)\n        rootElement?.addEventListener(\"mouseup\", onMouseUp)\n      }\n    )\n\n    return () => {\n      removeRootListener()\n    }\n  }, [activeCell, draggingDirection, editor, resetState])\n\n  const isHeightChanging = (direction: MouseDraggingDirection) => {\n    if (direction === \"bottom\") {\n      return true\n    }\n    return false\n  }\n\n  const updateRowHeight = useCallback(\n    (heightChange: number) => {\n      if (!activeCell) {\n        throw new Error(\"TableCellResizer: Expected active cell.\")\n      }\n\n      editor.update(\n        () => {\n          const tableCellNode = $getNearestNodeFromDOMNode(activeCell.elem)\n          if (!$isTableCellNode(tableCellNode)) {\n            throw new Error(\"TableCellResizer: Table cell node not found.\")\n          }\n\n          const tableNode = $getTableNodeFromLexicalNodeOrThrow(tableCellNode)\n\n          const tableRowIndex =\n            $getTableRowIndexFromTableCellNode(tableCellNode) +\n            tableCellNode.getRowSpan() -\n            1\n\n          const tableRows = tableNode.getChildren()\n\n          if (tableRowIndex >= tableRows.length || tableRowIndex < 0) {\n            throw new Error(\"Expected table cell to be inside of table row.\")\n          }\n\n          const tableRow = tableRows[tableRowIndex]\n\n          if (!$isTableRowNode(tableRow)) {\n            throw new Error(\"Expected table row\")\n          }\n\n          let height = tableRow.getHeight()\n          if (height === undefined) {\n            const rowCells = tableRow.getChildren<TableCellNode>()\n            height = Math.min(\n              ...rowCells.map(\n                (cell) => getCellNodeHeight(cell, editor) ?? Infinity\n              )\n            )\n          }\n\n          const newHeight = Math.max(height + heightChange, MIN_ROW_HEIGHT)\n          tableRow.setHeight(newHeight)\n        },\n        { tag: \"skip-scroll-into-view\" }\n      )\n    },\n    [activeCell, editor]\n  )\n\n  const getCellNodeHeight = (\n    cell: TableCellNode,\n    activeEditor: LexicalEditor\n  ): number | undefined => {\n    const domCellNode = activeEditor.getElementByKey(cell.getKey())\n    return domCellNode?.clientHeight\n  }\n\n  const getCellColumnIndex = (\n    tableCellNode: TableCellNode,\n    tableMap: TableMapType\n  ) => {\n    for (let row = 0; row < tableMap.length; row++) {\n      for (let column = 0; column < tableMap[row].length; column++) {\n        if (tableMap[row][column].cell === tableCellNode) {\n          return column\n        }\n      }\n    }\n  }\n\n  const updateColumnWidth = useCallback(\n    (widthChange: number) => {\n      if (!activeCell) {\n        throw new Error(\"TableCellResizer: Expected active cell.\")\n      }\n      editor.update(\n        () => {\n          const tableCellNode = $getNearestNodeFromDOMNode(activeCell.elem)\n          if (!$isTableCellNode(tableCellNode)) {\n            throw new Error(\"TableCellResizer: Table cell node not found.\")\n          }\n\n          const tableNode = $getTableNodeFromLexicalNodeOrThrow(tableCellNode)\n          const [tableMap] = $computeTableMapSkipCellCheck(\n            tableNode,\n            null,\n            null\n          )\n          const columnIndex = getCellColumnIndex(tableCellNode, tableMap)\n          if (columnIndex === undefined) {\n            throw new Error(\"TableCellResizer: Table column not found.\")\n          }\n\n          const colWidths = tableNode.getColWidths()\n          if (!colWidths) {\n            return\n          }\n          const width = colWidths[columnIndex]\n          if (width === undefined) {\n            return\n          }\n          const newColWidths = [...colWidths]\n          const newWidth = Math.max(width + widthChange, MIN_COLUMN_WIDTH)\n          newColWidths[columnIndex] = newWidth\n          tableNode.setColWidths(newColWidths)\n        },\n        { tag: \"skip-scroll-into-view\" }\n      )\n    },\n    [activeCell, editor]\n  )\n\n  const mouseUpHandler = useCallback(\n    (direction: MouseDraggingDirection) => {\n      const handler = (event: MouseEvent) => {\n        event.preventDefault()\n        event.stopPropagation()\n\n        if (!activeCell) {\n          throw new Error(\"TableCellResizer: Expected active cell.\")\n        }\n\n        if (mouseStartPosRef.current) {\n          const { x, y } = mouseStartPosRef.current\n\n          if (activeCell === null) {\n            return\n          }\n          const zoom = calculateZoomLevel(event.target as Element)\n\n          if (isHeightChanging(direction)) {\n            const heightChange = (event.clientY - y) / zoom\n            updateRowHeight(heightChange)\n          } else {\n            const widthChange = (event.clientX - x) / zoom\n            updateColumnWidth(widthChange)\n          }\n\n          resetState()\n          document.removeEventListener(\"mouseup\", handler)\n        }\n      }\n      return handler\n    },\n    [activeCell, resetState, updateColumnWidth, updateRowHeight]\n  )\n\n  const toggleResize = useCallback(\n    (direction: MouseDraggingDirection): MouseEventHandler<HTMLDivElement> =>\n      (event) => {\n        event.preventDefault()\n        event.stopPropagation()\n\n        if (!activeCell) {\n          throw new Error(\"TableCellResizer: Expected active cell.\")\n        }\n\n        mouseStartPosRef.current = {\n          x: event.clientX,\n          y: event.clientY,\n        }\n        updateMouseCurrentPos(mouseStartPosRef.current)\n        updateDraggingDirection(direction)\n\n        document.addEventListener(\"mouseup\", mouseUpHandler(direction))\n      },\n    [activeCell, mouseUpHandler]\n  )\n\n  const getResizers = useCallback(() => {\n    if (activeCell) {\n      const { height, width, top, left } =\n        activeCell.elem.getBoundingClientRect()\n      const zoom = calculateZoomLevel(activeCell.elem)\n      const zoneWidth = 10 // Pixel width of the zone where you can drag the edge\n      const styles = {\n        bottom: {\n          backgroundColor: \"none\",\n          cursor: \"row-resize\",\n          height: `${zoneWidth}px`,\n          left: `${window.pageXOffset + left}px`,\n          top: `${window.pageYOffset + top + height - zoneWidth / 2}px`,\n          width: `${width}px`,\n        },\n        right: {\n          backgroundColor: \"none\",\n          cursor: \"col-resize\",\n          height: `${height}px`,\n          left: `${window.pageXOffset + left + width - zoneWidth / 2}px`,\n          top: `${window.pageYOffset + top}px`,\n          width: `${zoneWidth}px`,\n        },\n      }\n\n      const tableRect = tableRectRef.current\n\n      if (draggingDirection && mouseCurrentPos && tableRect) {\n        if (isHeightChanging(draggingDirection)) {\n          styles[draggingDirection].left = `${\n            window.pageXOffset + tableRect.left\n          }px`\n          styles[draggingDirection].top = `${\n            window.pageYOffset + mouseCurrentPos.y / zoom\n          }px`\n          styles[draggingDirection].height = \"3px\"\n          styles[draggingDirection].width = `${tableRect.width}px`\n        } else {\n          styles[draggingDirection].top = `${\n            window.pageYOffset + tableRect.top\n          }px`\n          styles[draggingDirection].left = `${\n            window.pageXOffset + mouseCurrentPos.x / zoom\n          }px`\n          styles[draggingDirection].width = \"3px\"\n          styles[draggingDirection].height = `${tableRect.height}px`\n        }\n\n        styles[draggingDirection].backgroundColor = \"#adf\"\n      }\n\n      return styles\n    }\n\n    return {\n      bottom: null,\n      left: null,\n      right: null,\n      top: null,\n    }\n  }, [activeCell, draggingDirection, mouseCurrentPos])\n\n  const resizerStyles = getResizers()\n\n  return (\n    <div ref={resizerRef}>\n      {activeCell != null && !isMouseDown && (\n        <>\n          <div\n            className=\"TableCellResizer__ui absolute\"\n            style={resizerStyles.right || undefined}\n            onMouseDown={toggleResize(\"right\")}\n          />\n          <div\n            className=\"TableCellResizer__ui absolute\"\n            style={resizerStyles.bottom || undefined}\n            onMouseDown={toggleResize(\"bottom\")}\n          />\n        </>\n      )}\n    </div>\n  )\n}\n\nexport function TableCellResizerPlugin(): null | React.ReactElement {\n  const [editor] = useLexicalComposerContext()\n  const isEditable = useLexicalEditable()\n  const [bodyRef, setBodyRef] = useState<HTMLElement | null>(null)\n\n  useEffect(() => {\n    setBodyRef(document.body)\n  }, [])\n\n  return useMemo(\n    () =>\n      isEditable && bodyRef\n        ? createPortal(<TableCellResizer editor={editor} />, bodyRef)\n        : null,\n    [editor, isEditable, bodyRef]\n  )\n}\n",
      "type": "registry:component",
      "target": "components/editor/plugins/table-cell-resizer-plugin.tsx"
    },
    {
      "path": "registry/new-york-v4/editor/plugins/table-hover-actions-plugin.tsx",
      "content": "\"use client\"\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nimport { JSX, useEffect, useMemo, useRef, useState } from \"react\"\nimport * as React from \"react\"\nimport { useLexicalComposerContext } from \"@lexical/react/LexicalComposerContext\"\nimport { useLexicalEditable } from \"@lexical/react/useLexicalEditable\"\nimport {\n  $getTableColumnIndexFromTableCellNode,\n  $getTableRowIndexFromTableCellNode,\n  $insertTableColumn__EXPERIMENTAL,\n  $insertTableRow__EXPERIMENTAL,\n  $isTableCellNode,\n  $isTableNode,\n  TableCellNode,\n  TableNode,\n  TableRowNode,\n} from \"@lexical/table\"\nimport { $findMatchingParent, mergeRegister } from \"@lexical/utils\"\nimport { $getNearestNodeFromDOMNode, NodeKey } from \"lexical\"\nimport { PlusIcon } from \"lucide-react\"\nimport { createPortal } from \"react-dom\"\n\nimport { useDebounce } from \"@/registry/new-york-v4/editor/editor-hooks/use-debounce\"\n\nconst BUTTON_WIDTH_PX = 20\n\nfunction TableHoverActionsContainer({\n  anchorElem,\n}: {\n  anchorElem: HTMLElement\n}): JSX.Element | null {\n  const [editor] = useLexicalComposerContext()\n  const isEditable = useLexicalEditable()\n  const [isShownRow, setShownRow] = useState<boolean>(false)\n  const [isShownColumn, setShownColumn] = useState<boolean>(false)\n  const [shouldListenMouseMove, setShouldListenMouseMove] =\n    useState<boolean>(false)\n  const [position, setPosition] = useState({})\n  const tableSetRef = useRef<Set<NodeKey>>(new Set())\n  const tableCellDOMNodeRef = useRef<HTMLElement | null>(null)\n\n  const debouncedOnMouseMove = useDebounce(\n    (event: MouseEvent) => {\n      const { isOutside, tableDOMNode } = getMouseInfo(event)\n\n      if (isOutside) {\n        setShownRow(false)\n        setShownColumn(false)\n        return\n      }\n\n      if (!tableDOMNode) {\n        return\n      }\n\n      tableCellDOMNodeRef.current = tableDOMNode\n\n      let hoveredRowNode: TableCellNode | null = null\n      let hoveredColumnNode: TableCellNode | null = null\n      let tableDOMElement: HTMLElement | null = null\n\n      editor.update(() => {\n        const maybeTableCell = $getNearestNodeFromDOMNode(tableDOMNode)\n\n        if ($isTableCellNode(maybeTableCell)) {\n          const table = $findMatchingParent(maybeTableCell, (node) =>\n            $isTableNode(node)\n          )\n          if (!$isTableNode(table)) {\n            return\n          }\n\n          tableDOMElement = editor.getElementByKey(table?.getKey())\n\n          if (tableDOMElement) {\n            const rowCount = table.getChildrenSize()\n            const colCount = (\n              (table as TableNode).getChildAtIndex(0) as TableRowNode\n            )?.getChildrenSize()\n\n            const rowIndex = $getTableRowIndexFromTableCellNode(maybeTableCell)\n            const colIndex =\n              $getTableColumnIndexFromTableCellNode(maybeTableCell)\n\n            if (rowIndex === rowCount - 1) {\n              hoveredRowNode = maybeTableCell\n            } else if (colIndex === colCount - 1) {\n              hoveredColumnNode = maybeTableCell\n            }\n          }\n        }\n      })\n\n      if (tableDOMElement) {\n        const {\n          width: tableElemWidth,\n          y: tableElemY,\n          right: tableElemRight,\n          left: tableElemLeft,\n          bottom: tableElemBottom,\n          height: tableElemHeight,\n        } = (tableDOMElement as HTMLTableElement).getBoundingClientRect()\n\n        const { y: editorElemY, left: editorElemLeft } =\n          anchorElem.getBoundingClientRect()\n\n        if (hoveredRowNode) {\n          setShownColumn(false)\n          setShownRow(true)\n          setPosition({\n            height: BUTTON_WIDTH_PX,\n            left: tableElemLeft - editorElemLeft,\n            top: tableElemBottom - editorElemY + 5,\n            width: tableElemWidth,\n          })\n        } else if (hoveredColumnNode) {\n          setShownColumn(true)\n          setShownRow(false)\n          setPosition({\n            height: tableElemHeight,\n            left: tableElemRight - editorElemLeft + 5,\n            top: tableElemY - editorElemY,\n            width: BUTTON_WIDTH_PX,\n          })\n        }\n      }\n    },\n    50,\n    250\n  )\n\n  // Hide the buttons on any table dimensions change to prevent last row cells\n  // overlap behind the 'Add Row' button when text entry changes cell height\n  const tableResizeObserver = useMemo(() => {\n    return new ResizeObserver(() => {\n      setShownRow(false)\n      setShownColumn(false)\n    })\n  }, [])\n\n  useEffect(() => {\n    if (!shouldListenMouseMove) {\n      return\n    }\n\n    document.addEventListener(\"mousemove\", debouncedOnMouseMove)\n\n    return () => {\n      setShownRow(false)\n      setShownColumn(false)\n      debouncedOnMouseMove.cancel()\n      document.removeEventListener(\"mousemove\", debouncedOnMouseMove)\n    }\n  }, [shouldListenMouseMove, debouncedOnMouseMove])\n\n  useEffect(() => {\n    return mergeRegister(\n      editor.registerMutationListener(\n        TableNode,\n        (mutations) => {\n          editor.getEditorState().read(() => {\n            for (const [key, type] of Array.from(mutations)) {\n              const tableDOMElement = editor.getElementByKey(key)\n              switch (type) {\n                case \"created\":\n                  tableSetRef.current.add(key)\n                  setShouldListenMouseMove(tableSetRef.current.size > 0)\n                  if (tableDOMElement) {\n                    tableResizeObserver.observe(tableDOMElement)\n                  }\n                  break\n\n                case \"destroyed\":\n                  tableSetRef.current.delete(key)\n                  setShouldListenMouseMove(tableSetRef.current.size > 0)\n                  // Reset resize observers\n                  tableResizeObserver.disconnect()\n                  tableSetRef.current.forEach((tableKey: NodeKey) => {\n                    const tableElement = editor.getElementByKey(tableKey)\n                    if (tableElement) {\n                      tableResizeObserver.observe(tableElement)\n                    }\n                  })\n                  break\n\n                default:\n                  break\n              }\n            }\n          })\n        },\n        { skipInitialization: false }\n      )\n    )\n  }, [editor, tableResizeObserver])\n\n  const insertAction = (insertRow: boolean) => {\n    editor.update(() => {\n      if (tableCellDOMNodeRef.current) {\n        const maybeTableNode = $getNearestNodeFromDOMNode(\n          tableCellDOMNodeRef.current\n        )\n        maybeTableNode?.selectEnd()\n        if (insertRow) {\n          $insertTableRow__EXPERIMENTAL()\n          setShownRow(false)\n        } else {\n          $insertTableColumn__EXPERIMENTAL()\n          setShownColumn(false)\n        }\n      }\n    })\n  }\n\n  if (!isEditable) {\n    return null\n  }\n\n  return (\n    <>\n      {isShownRow && (\n        <button\n          className={\n            \"EditorTheme__tableAddRows bg-accent hover:bg-accent/80 absolute flex w-[calc(100%-25px)] cursor-pointer items-center justify-center border-0\"\n          }\n          style={{ ...position }}\n          onClick={() => insertAction(true)}\n        >\n          <PlusIcon className=\"h-4 w-4\" />\n        </button>\n      )}\n      {isShownColumn && (\n        <button\n          className={\n            \"EditorTheme__tableAddColumns bg-accent hover:bg-accent/80 absolute flex w-[calc(100%-25px)] cursor-pointer items-center justify-center border-0\"\n          }\n          style={{ ...position }}\n          onClick={() => insertAction(false)}\n        >\n          <PlusIcon className=\"h-4 w-4\" />\n        </button>\n      )}\n    </>\n  )\n}\n\nfunction getMouseInfo(event: MouseEvent): {\n  tableDOMNode: HTMLElement | null\n  isOutside: boolean\n} {\n  const target = event.target\n\n  if (target && target instanceof HTMLElement) {\n    const tableDOMNode = target.closest<HTMLElement>(\n      \"td.EditorTheme__tableCell, th.EditorTheme__tableCell\"\n    )\n\n    const isOutside = !(\n      tableDOMNode ||\n      target.closest<HTMLElement>(\"button.EditorTheme__tableAddRows\") ||\n      target.closest<HTMLElement>(\"button.EditorTheme__tableAddColumns\") ||\n      target.closest<HTMLElement>(\"div.TableCellResizer__resizer\")\n    )\n\n    return { isOutside, tableDOMNode }\n  } else {\n    return { isOutside: true, tableDOMNode: null }\n  }\n}\n\nexport function TableHoverActionsPlugin({\n  anchorElem,\n}: {\n  anchorElem: HTMLDivElement | null\n}): React.ReactPortal | null {\n  const isEditable = useLexicalEditable()\n\n  if (!anchorElem) {\n    return null\n  }\n\n  return isEditable\n    ? createPortal(\n        <TableHoverActionsContainer anchorElem={anchorElem} />,\n        anchorElem\n      )\n    : null\n}\n",
      "type": "registry:component",
      "target": "components/editor/plugins/table-hover-actions-plugin.tsx"
    },
    {
      "path": "registry/new-york-v4/editor/plugins/toolbar/block-insert-plugin.tsx",
      "content": "\"use client\"\n\nimport { PlusIcon } from \"lucide-react\"\n\nimport { useEditorModal } from \"@/registry/new-york-v4/editor/editor-hooks/use-modal\"\nimport {\n  Select,\n  SelectContent,\n  SelectGroup,\n  SelectTrigger,\n} from \"@/registry/new-york-v4/ui/select\"\n\nexport function BlockInsertPlugin({ children }: { children: React.ReactNode }) {\n  const [modal] = useEditorModal()\n\n  return (\n    <>\n      {modal}\n      <Select value={\"\"}>\n        <SelectTrigger className=\"!h-8 w-min gap-1\">\n          <PlusIcon className=\"size-4\" />\n          <span>Insert</span>\n        </SelectTrigger>\n        <SelectContent>\n          <SelectGroup>{children}</SelectGroup>\n        </SelectContent>\n      </Select>\n    </>\n  )\n}\n",
      "type": "registry:component",
      "target": "components/editor/plugins/toolbar/block-insert-plugin.tsx"
    },
    {
      "path": "registry/new-york-v4/editor/plugins/toolbar/block-insert/insert-table.tsx",
      "content": "\"use client\"\n\nimport { TableIcon } from \"lucide-react\"\n\nimport { useToolbarContext } from \"@/registry/new-york-v4/editor/context/toolbar-context\"\nimport { InsertTableDialog } from \"@/registry/new-york-v4/editor/plugins/table-plugin\"\nimport { SelectItem } from \"@/registry/new-york-v4/ui/select\"\n\nexport function InsertTable() {\n  const { activeEditor, showModal } = useToolbarContext()\n\n  return (\n    <SelectItem\n      value=\"table\"\n      onPointerUp={() =>\n        showModal(\"Insert Table\", (onClose) => (\n          <InsertTableDialog activeEditor={activeEditor} onClose={onClose} />\n        ))\n      }\n      className=\"\"\n    >\n      <div className=\"flex items-center gap-1\">\n        <TableIcon className=\"size-4\" />\n        <span>Table</span>\n      </div>\n    </SelectItem>\n  )\n}\n",
      "type": "registry:component",
      "target": "components/editor/plugins/toolbar/block-insert/insert-table.tsx"
    },
    {
      "path": "registry/new-york-v4/editor/editor-hooks/use-modal.tsx",
      "content": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nimport { JSX, useCallback, useMemo, useState } from \"react\"\nimport * as React from \"react\"\n\nimport {\n  Dialog,\n  DialogContent,\n  DialogHeader,\n  DialogTitle,\n} from \"@/registry/new-york-v4/ui/dialog\"\n\nexport function useEditorModal(): [\n  JSX.Element | null,\n  (title: string, showModal: (onClose: () => void) => JSX.Element) => void,\n] {\n  const [modalContent, setModalContent] = useState<null | {\n    closeOnClickOutside: boolean\n    content: JSX.Element\n    title: string\n  }>(null)\n\n  const onClose = useCallback(() => {\n    setModalContent(null)\n  }, [])\n\n  const modal = useMemo(() => {\n    if (modalContent === null) {\n      return null\n    }\n    const { title, content } = modalContent\n    return (\n      <Dialog open={true} onOpenChange={onClose}>\n        <DialogContent>\n          <DialogHeader>\n            <DialogTitle>{title}</DialogTitle>\n          </DialogHeader>\n          {content}\n        </DialogContent>\n      </Dialog>\n    )\n  }, [modalContent, onClose])\n\n  const showModal = useCallback(\n    (\n      title: string,\n      getContent: (onClose: () => void) => JSX.Element,\n      closeOnClickOutside = false\n    ) => {\n      setModalContent({\n        closeOnClickOutside,\n        content: getContent(onClose),\n        title,\n      })\n    },\n    [onClose]\n  )\n\n  return [modal, showModal]\n}\n",
      "type": "registry:component",
      "target": "components/editor/editor-hooks/use-modal.tsx"
    },
    {
      "path": "registry/new-york-v4/editor/editor-hooks/use-debounce.ts",
      "content": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nimport { useMemo, useRef } from \"react\"\nimport { debounce } from \"lodash-es\"\n\nexport function useDebounce<T extends (...args: never[]) => void>(\n  fn: T,\n  ms: number,\n  maxWait?: number\n) {\n  const funcRef = useRef<T | null>(null)\n  funcRef.current = fn\n\n  return useMemo(\n    () =>\n      debounce(\n        (...args: Parameters<T>) => {\n          if (funcRef.current) {\n            funcRef.current(...args)\n          }\n        },\n        ms,\n        { maxWait }\n      ),\n    [ms, maxWait]\n  )\n}\n",
      "type": "registry:component",
      "target": "components/editor/editor-hooks/use-debounce.ts"
    },
    {
      "path": "registry/new-york-v4/editor/shared/invariant.ts",
      "content": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// invariant(condition, message) will refine types based on \"condition\", and\n// if \"condition\" is false will throw an error. This function is special-cased\n// in flow itself, so we can't name it anything else.\nexport function invariant(\n  cond?: boolean,\n  message?: string,\n  ...args: string[]\n): asserts cond {\n  if (cond) {\n    return\n  }\n\n  throw new Error(\n    \"Internal Lexical error: invariant() is meant to be replaced at compile \" +\n      \"time. There is no runtime version. Error: \" +\n      message\n  )\n}\n",
      "type": "registry:component",
      "target": "components/editor/shared/invariant.ts"
    },
    {
      "path": "registry/new-york-v4/editor/transformers/markdown-table-transformer.ts",
      "content": "import {\n  $convertFromMarkdownString,\n  $convertToMarkdownString,\n  CHECK_LIST,\n  ELEMENT_TRANSFORMERS,\n  ElementTransformer,\n  MULTILINE_ELEMENT_TRANSFORMERS,\n  TEXT_FORMAT_TRANSFORMERS,\n  TEXT_MATCH_TRANSFORMERS,\n} from \"@lexical/markdown\"\nimport {\n  $createTableCellNode,\n  $createTableNode,\n  $createTableRowNode,\n  $isTableCellNode,\n  $isTableNode,\n  $isTableRowNode,\n  TableCellHeaderStates,\n  TableCellNode,\n  TableNode,\n  TableRowNode,\n} from \"@lexical/table\"\nimport { $isParagraphNode, $isTextNode, LexicalNode } from \"lexical\"\n\nimport { EMOJI } from \"@/registry/new-york-v4/editor/transformers/markdown-emoji-transformer\"\nimport { EQUATION } from \"@/registry/new-york-v4/editor/transformers/markdown-equation-transformer\"\nimport { HR } from \"@/registry/new-york-v4/editor/transformers/markdown-hr-transformer\"\nimport { IMAGE } from \"@/registry/new-york-v4/editor/transformers/markdown-image-transformer\"\nimport { TWEET } from \"@/registry/new-york-v4/editor/transformers/markdown-tweet-transformer\"\n\n// Very primitive table setup\nconst TABLE_ROW_REG_EXP = /^(?:\\|)(.+)(?:\\|)\\s?$/\nconst TABLE_ROW_DIVIDER_REG_EXP = /^(\\| ?:?-*:? ?)+\\|\\s?$/\n\nconst OTHER_MARKDOWN_TRANSFORMERS = [\n  HR,\n  IMAGE,\n  EMOJI,\n  EQUATION,\n  TWEET,\n  CHECK_LIST,\n  ...ELEMENT_TRANSFORMERS,\n  ...MULTILINE_ELEMENT_TRANSFORMERS,\n  ...TEXT_FORMAT_TRANSFORMERS,\n  ...TEXT_MATCH_TRANSFORMERS,\n]\n\nexport const TABLE: ElementTransformer = {\n  dependencies: [TableNode, TableRowNode, TableCellNode],\n  export: (node: LexicalNode) => {\n    if (!$isTableNode(node)) {\n      return null\n    }\n\n    const output: string[] = []\n\n    for (const row of node.getChildren()) {\n      const rowOutput = []\n      if (!$isTableRowNode(row)) {\n        continue\n      }\n\n      let isHeaderRow = false\n      for (const cell of row.getChildren()) {\n        // It's TableCellNode so it's just to make flow happy\n        if ($isTableCellNode(cell)) {\n          rowOutput.push(\n            $convertToMarkdownString(OTHER_MARKDOWN_TRANSFORMERS, cell).replace(\n              /\\n/g,\n              \"\\\\n\"\n            )\n          )\n          if (cell.__headerState === TableCellHeaderStates.ROW) {\n            isHeaderRow = true\n          }\n        }\n      }\n\n      output.push(`| ${rowOutput.join(\" | \")} |`)\n      if (isHeaderRow) {\n        output.push(`| ${rowOutput.map((_) => \"---\").join(\" | \")} |`)\n      }\n    }\n\n    return output.join(\"\\n\")\n  },\n  regExp: TABLE_ROW_REG_EXP,\n  replace: (parentNode, _1, match) => {\n    // Header row\n    if (TABLE_ROW_DIVIDER_REG_EXP.test(match[0])) {\n      const table = parentNode.getPreviousSibling()\n      if (!table || !$isTableNode(table)) {\n        return\n      }\n\n      const rows = table.getChildren()\n      const lastRow = rows[rows.length - 1]\n      if (!lastRow || !$isTableRowNode(lastRow)) {\n        return\n      }\n\n      // Add header state to row cells\n      lastRow.getChildren().forEach((cell) => {\n        if (!$isTableCellNode(cell)) {\n          return\n        }\n        cell.setHeaderStyles(\n          TableCellHeaderStates.ROW,\n          TableCellHeaderStates.ROW\n        )\n      })\n\n      // Remove line\n      parentNode.remove()\n      return\n    }\n\n    const matchCells = mapToTableCells(match[0])\n\n    if (matchCells == null) {\n      return\n    }\n\n    const rows = [matchCells]\n    let sibling = parentNode.getPreviousSibling()\n    let maxCells = matchCells.length\n\n    while (sibling) {\n      if (!$isParagraphNode(sibling)) {\n        break\n      }\n\n      if (sibling.getChildrenSize() !== 1) {\n        break\n      }\n\n      const firstChild = sibling.getFirstChild()\n\n      if (!$isTextNode(firstChild)) {\n        break\n      }\n\n      const cells = mapToTableCells(firstChild.getTextContent())\n\n      if (cells == null) {\n        break\n      }\n\n      maxCells = Math.max(maxCells, cells.length)\n      rows.unshift(cells)\n      const previousSibling = sibling.getPreviousSibling()\n      sibling.remove()\n      sibling = previousSibling\n    }\n\n    const table = $createTableNode()\n\n    for (const cells of rows) {\n      const tableRow = $createTableRowNode()\n      table.append(tableRow)\n\n      for (let i = 0; i < maxCells; i++) {\n        tableRow.append(i < cells.length ? cells[i] : $createTableCell(\"\"))\n      }\n    }\n\n    const previousSibling = parentNode.getPreviousSibling()\n    if (\n      $isTableNode(previousSibling) &&\n      getTableColumnsSize(previousSibling) === maxCells\n    ) {\n      previousSibling.append(...table.getChildren())\n      parentNode.remove()\n    } else {\n      parentNode.replace(table)\n    }\n\n    table.selectEnd()\n  },\n  type: \"element\",\n}\n\nfunction getTableColumnsSize(table: TableNode) {\n  const row = table.getFirstChild()\n  return $isTableRowNode(row) ? row.getChildrenSize() : 0\n}\n\nconst $createTableCell = (textContent: string): TableCellNode => {\n  textContent = textContent.replace(/\\\\n/g, \"\\n\")\n  const cell = $createTableCellNode(TableCellHeaderStates.NO_STATUS)\n  $convertFromMarkdownString(textContent, OTHER_MARKDOWN_TRANSFORMERS, cell)\n  return cell\n}\n\nconst mapToTableCells = (textContent: string): Array<TableCellNode> | null => {\n  const match = textContent.match(TABLE_ROW_REG_EXP)\n  if (!match || !match[1]) {\n    return null\n  }\n  return match[1].split(\"|\").map((text) => $createTableCell(text))\n}\n",
      "type": "registry:component",
      "target": "components/editor/transformers/markdown-table-transformer.ts"
    }
  ]
}