{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "collapsible-plugin",
  "type": "registry:ui",
  "dependencies": [
    "@lexical/utils"
  ],
  "registryDependencies": [
    "select",
    "https://shadcn-editor.vercel.app/r/toolbar-plugin.json"
  ],
  "files": [
    {
      "path": "registry/new-york-v4/editor/plugins/collapsible-plugin.tsx",
      "content": "\"use client\"\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nimport { useEffect } from \"react\"\nimport { useLexicalComposerContext } from \"@lexical/react/LexicalComposerContext\"\nimport {\n  $findMatchingParent,\n  $insertNodeToNearestRoot,\n  mergeRegister,\n} from \"@lexical/utils\"\nimport {\n  $createParagraphNode,\n  $getSelection,\n  $isRangeSelection,\n  COMMAND_PRIORITY_LOW,\n  createCommand,\n  DELETE_CHARACTER_COMMAND,\n  ElementNode,\n  INSERT_PARAGRAPH_COMMAND,\n  KEY_ARROW_DOWN_COMMAND,\n  KEY_ARROW_LEFT_COMMAND,\n  KEY_ARROW_RIGHT_COMMAND,\n  KEY_ARROW_UP_COMMAND,\n  LexicalNode,\n} from \"lexical\"\n\nimport {\n  $createCollapsibleContainerNode,\n  $isCollapsibleContainerNode,\n  CollapsibleContainerNode,\n} from \"@/registry/new-york-v4/editor/nodes/collapsible-container-node\"\nimport {\n  $createCollapsibleContentNode,\n  $isCollapsibleContentNode,\n  CollapsibleContentNode,\n} from \"@/registry/new-york-v4/editor/nodes/collapsible-content-node\"\nimport {\n  $createCollapsibleTitleNode,\n  $isCollapsibleTitleNode,\n  CollapsibleTitleNode,\n} from \"@/registry/new-york-v4/editor/nodes/collapsible-title-node\"\n\nexport const INSERT_COLLAPSIBLE_COMMAND = createCommand<void>()\n\nexport function CollapsiblePlugin(): null {\n  const [editor] = useLexicalComposerContext()\n\n  useEffect(() => {\n    if (\n      !editor.hasNodes([\n        CollapsibleContainerNode,\n        CollapsibleTitleNode,\n        CollapsibleContentNode,\n      ])\n    ) {\n      throw new Error(\n        \"CollapsiblePlugin: CollapsibleContainerNode, CollapsibleTitleNode, or CollapsibleContentNode not registered on editor\"\n      )\n    }\n\n    const $onEscapeUp = () => {\n      const selection = $getSelection()\n      if (\n        $isRangeSelection(selection) &&\n        selection.isCollapsed() &&\n        selection.anchor.offset === 0\n      ) {\n        const container = $findMatchingParent(\n          selection.anchor.getNode(),\n          $isCollapsibleContainerNode\n        )\n\n        if ($isCollapsibleContainerNode(container)) {\n          const parent = container.getParent<ElementNode>()\n          if (\n            parent !== null &&\n            parent.getFirstChild<LexicalNode>() === container &&\n            selection.anchor.key ===\n              container.getFirstDescendant<LexicalNode>()?.getKey()\n          ) {\n            container.insertBefore($createParagraphNode())\n          }\n        }\n      }\n\n      return false\n    }\n\n    const $onEscapeDown = () => {\n      const selection = $getSelection()\n      if ($isRangeSelection(selection) && selection.isCollapsed()) {\n        const container = $findMatchingParent(\n          selection.anchor.getNode(),\n          $isCollapsibleContainerNode\n        )\n\n        if ($isCollapsibleContainerNode(container)) {\n          const parent = container.getParent<ElementNode>()\n          if (\n            parent !== null &&\n            parent.getLastChild<LexicalNode>() === container\n          ) {\n            const titleParagraph = container.getFirstDescendant<LexicalNode>()\n            const contentParagraph = container.getLastDescendant<LexicalNode>()\n\n            if (\n              (contentParagraph !== null &&\n                selection.anchor.key === contentParagraph.getKey() &&\n                selection.anchor.offset ===\n                  contentParagraph.getTextContentSize()) ||\n              (titleParagraph !== null &&\n                selection.anchor.key === titleParagraph.getKey() &&\n                selection.anchor.offset === titleParagraph.getTextContentSize())\n            ) {\n              container.insertAfter($createParagraphNode())\n            }\n          }\n        }\n      }\n\n      return false\n    }\n\n    return mergeRegister(\n      // Structure enforcing transformers for each node type. In case nesting structure is not\n      // \"Container > Title + Content\" it'll unwrap nodes and convert it back\n      // to regular content.\n      editor.registerNodeTransform(CollapsibleContentNode, (node) => {\n        const parent = node.getParent<ElementNode>()\n        if (!$isCollapsibleContainerNode(parent)) {\n          const children = node.getChildren<LexicalNode>()\n          for (const child of children) {\n            node.insertBefore(child)\n          }\n          node.remove()\n        }\n      }),\n\n      editor.registerNodeTransform(CollapsibleTitleNode, (node) => {\n        const parent = node.getParent<ElementNode>()\n        if (!$isCollapsibleContainerNode(parent)) {\n          node.replace(\n            $createParagraphNode().append(...node.getChildren<LexicalNode>())\n          )\n          return\n        }\n      }),\n\n      editor.registerNodeTransform(CollapsibleContainerNode, (node) => {\n        const children = node.getChildren<LexicalNode>()\n        if (\n          children.length !== 2 ||\n          !$isCollapsibleTitleNode(children[0]) ||\n          !$isCollapsibleContentNode(children[1])\n        ) {\n          for (const child of children) {\n            node.insertBefore(child)\n          }\n          node.remove()\n        }\n      }),\n\n      // This handles the case when container is collapsed and we delete its previous sibling\n      // into it, it would cause collapsed content deleted (since it's display: none, and selection\n      // swallows it when deletes single char). Instead we expand container, which is although\n      // not perfect, but avoids bigger problem\n      editor.registerCommand(\n        DELETE_CHARACTER_COMMAND,\n        () => {\n          const selection = $getSelection()\n          if (\n            !$isRangeSelection(selection) ||\n            !selection.isCollapsed() ||\n            selection.anchor.offset !== 0\n          ) {\n            return false\n          }\n\n          const anchorNode = selection.anchor.getNode()\n          const topLevelElement = anchorNode.getTopLevelElement()\n          if (topLevelElement === null) {\n            return false\n          }\n\n          const container = topLevelElement.getPreviousSibling<LexicalNode>()\n          if (!$isCollapsibleContainerNode(container) || container.getOpen()) {\n            return false\n          }\n\n          container.setOpen(true)\n          return true\n        },\n        COMMAND_PRIORITY_LOW\n      ),\n\n      // When collapsible is the last child pressing down/right arrow will insert paragraph\n      // below it to allow adding more content. It's similar what $insertBlockNode\n      // (mainly for decorators), except it'll always be possible to continue adding\n      // new content even if trailing paragraph is accidentally deleted\n      editor.registerCommand(\n        KEY_ARROW_DOWN_COMMAND,\n        $onEscapeDown,\n        COMMAND_PRIORITY_LOW\n      ),\n\n      editor.registerCommand(\n        KEY_ARROW_RIGHT_COMMAND,\n        $onEscapeDown,\n        COMMAND_PRIORITY_LOW\n      ),\n\n      // When collapsible is the first child pressing up/left arrow will insert paragraph\n      // above it to allow adding more content. It's similar what $insertBlockNode\n      // (mainly for decorators), except it'll always be possible to continue adding\n      // new content even if leading paragraph is accidentally deleted\n      editor.registerCommand(\n        KEY_ARROW_UP_COMMAND,\n        $onEscapeUp,\n        COMMAND_PRIORITY_LOW\n      ),\n\n      editor.registerCommand(\n        KEY_ARROW_LEFT_COMMAND,\n        $onEscapeUp,\n        COMMAND_PRIORITY_LOW\n      ),\n\n      // Enter goes from Title to Content rather than a new line inside Title\n      editor.registerCommand(\n        INSERT_PARAGRAPH_COMMAND,\n        () => {\n          const selection = $getSelection()\n          if ($isRangeSelection(selection)) {\n            const titleNode = $findMatchingParent(\n              selection.anchor.getNode(),\n              (node) => $isCollapsibleTitleNode(node)\n            )\n\n            if ($isCollapsibleTitleNode(titleNode)) {\n              const container = titleNode.getParent<ElementNode>()\n              if (container && $isCollapsibleContainerNode(container)) {\n                if (!container.getOpen()) {\n                  container.toggleOpen()\n                }\n                titleNode.getNextSibling()?.selectEnd()\n                return true\n              }\n            }\n          }\n\n          return false\n        },\n        COMMAND_PRIORITY_LOW\n      ),\n      editor.registerCommand(\n        INSERT_COLLAPSIBLE_COMMAND,\n        () => {\n          editor.update(() => {\n            const title = $createCollapsibleTitleNode()\n            const paragraph = $createParagraphNode()\n            $insertNodeToNearestRoot(\n              $createCollapsibleContainerNode(true).append(\n                title.append(paragraph),\n                $createCollapsibleContentNode().append($createParagraphNode())\n              )\n            )\n            paragraph.select()\n          })\n          return true\n        },\n        COMMAND_PRIORITY_LOW\n      )\n    )\n  }, [editor])\n\n  return null\n}\n",
      "type": "registry:component",
      "target": "components/editor/plugins/collapsible-plugin.tsx"
    },
    {
      "path": "registry/new-york-v4/editor/nodes/collapsible-container-node.ts",
      "content": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nimport {\n  DOMConversionMap,\n  DOMConversionOutput,\n  DOMExportOutput,\n  EditorConfig,\n  ElementNode,\n  isHTMLElement,\n  LexicalEditor,\n  LexicalNode,\n  NodeKey,\n  SerializedElementNode,\n  Spread,\n} from \"lexical\"\n\nimport { IS_CHROME } from \"@/registry/new-york-v4/editor/shared/environment\"\nimport { invariant } from \"@/registry/new-york-v4/editor/shared/invariant\"\nimport { setDomHiddenUntilFound } from \"@/registry/new-york-v4/editor/utils/collapsible\"\n\ntype SerializedCollapsibleContainerNode = Spread<\n  {\n    open: boolean\n  },\n  SerializedElementNode\n>\n\nexport function $convertDetailsElement(\n  domNode: HTMLDetailsElement\n): DOMConversionOutput | null {\n  const isOpen = domNode.open !== undefined ? domNode.open : true\n  const node = $createCollapsibleContainerNode(isOpen)\n  return {\n    node,\n  }\n}\n\nexport class CollapsibleContainerNode extends ElementNode {\n  __open: boolean\n\n  constructor(open: boolean, key?: NodeKey) {\n    super(key)\n    this.__open = open\n  }\n\n  static getType(): string {\n    return \"collapsible-container\"\n  }\n\n  static clone(node: CollapsibleContainerNode): CollapsibleContainerNode {\n    return new CollapsibleContainerNode(node.__open, node.__key)\n  }\n\n  createDOM(config: EditorConfig, editor: LexicalEditor): HTMLElement {\n    // details is not well supported in Chrome #5582\n    let dom: HTMLElement\n    if (IS_CHROME) {\n      dom = document.createElement(\"div\")\n      dom.setAttribute(\"open\", \"\")\n    } else {\n      const detailsDom = document.createElement(\"details\")\n      detailsDom.open = this.__open\n      detailsDom.addEventListener(\"toggle\", () => {\n        const open = editor.getEditorState().read(() => this.getOpen())\n        if (open !== detailsDom.open) {\n          editor.update(() => this.toggleOpen())\n        }\n      })\n      dom = detailsDom\n    }\n    dom.classList.add(\"Collapsible__container\")\n\n    return dom\n  }\n\n  updateDOM(\n    prevNode: CollapsibleContainerNode,\n    dom: HTMLDetailsElement\n  ): boolean {\n    const currentOpen = this.__open\n    if (prevNode.__open !== currentOpen) {\n      // details is not well supported in Chrome #5582\n      if (IS_CHROME) {\n        const contentDom = dom.children[1]\n        invariant(\n          isHTMLElement(contentDom),\n          \"Expected contentDom to be an HTMLElement\"\n        )\n        if (currentOpen) {\n          dom.setAttribute(\"open\", \"\")\n          contentDom.hidden = false\n        } else {\n          dom.removeAttribute(\"open\")\n          setDomHiddenUntilFound(contentDom)\n        }\n      } else {\n        dom.open = this.__open\n      }\n    }\n\n    return false\n  }\n\n  static importDOM(): DOMConversionMap<HTMLDetailsElement> | null {\n    return {\n      details: (domNode: HTMLDetailsElement) => {\n        return {\n          conversion: $convertDetailsElement,\n          priority: 1,\n        }\n      },\n    }\n  }\n\n  static importJSON(\n    serializedNode: SerializedCollapsibleContainerNode\n  ): CollapsibleContainerNode {\n    const node = $createCollapsibleContainerNode(serializedNode.open)\n    return node\n  }\n\n  exportDOM(): DOMExportOutput {\n    const element = document.createElement(\"details\")\n    element.classList.add(\"Collapsible__container\")\n    element.setAttribute(\"open\", this.__open.toString())\n    return { element }\n  }\n\n  exportJSON(): SerializedCollapsibleContainerNode {\n    return {\n      ...super.exportJSON(),\n      open: this.__open,\n      type: \"collapsible-container\",\n      version: 1,\n    }\n  }\n\n  setOpen(open: boolean): void {\n    const writable = this.getWritable()\n    writable.__open = open\n  }\n\n  getOpen(): boolean {\n    return this.getLatest().__open\n  }\n\n  toggleOpen(): void {\n    this.setOpen(!this.getOpen())\n  }\n}\n\nexport function $createCollapsibleContainerNode(\n  isOpen: boolean\n): CollapsibleContainerNode {\n  return new CollapsibleContainerNode(isOpen)\n}\n\nexport function $isCollapsibleContainerNode(\n  node: LexicalNode | null | undefined\n): node is CollapsibleContainerNode {\n  return node instanceof CollapsibleContainerNode\n}\n",
      "type": "registry:component",
      "target": "components/editor/nodes/collapsible-container-node.ts"
    },
    {
      "path": "registry/new-york-v4/editor/nodes/collapsible-content-node.ts",
      "content": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nimport {\n  DOMConversionMap,\n  DOMConversionOutput,\n  DOMExportOutput,\n  EditorConfig,\n  ElementNode,\n  LexicalEditor,\n  LexicalNode,\n  SerializedElementNode,\n} from \"lexical\"\n\nimport { $isCollapsibleContainerNode } from \"@/registry/new-york-v4/editor/nodes/collapsible-container-node\"\nimport { IS_CHROME } from \"@/registry/new-york-v4/editor/shared/environment\"\nimport { invariant } from \"@/registry/new-york-v4/editor/shared/invariant\"\nimport {\n  domOnBeforeMatch,\n  setDomHiddenUntilFound,\n} from \"@/registry/new-york-v4/editor/utils/collapsible\"\n\ntype SerializedCollapsibleContentNode = SerializedElementNode\n\nexport function $convertCollapsibleContentElement(\n  domNode: HTMLElement\n): DOMConversionOutput | null {\n  const node = $createCollapsibleContentNode()\n  return {\n    node,\n  }\n}\n\nexport class CollapsibleContentNode extends ElementNode {\n  static getType(): string {\n    return \"collapsible-content\"\n  }\n\n  static clone(node: CollapsibleContentNode): CollapsibleContentNode {\n    return new CollapsibleContentNode(node.__key)\n  }\n\n  createDOM(config: EditorConfig, editor: LexicalEditor): HTMLElement {\n    const dom = document.createElement(\"div\")\n    dom.classList.add(\"pt-0\", \"pr-1\", \"pb-1\", \"pl-4\")\n    if (IS_CHROME) {\n      editor.getEditorState().read(() => {\n        const containerNode = this.getParentOrThrow()\n        invariant(\n          $isCollapsibleContainerNode(containerNode),\n          \"Expected parent node to be a CollapsibleContainerNode\"\n        )\n        if (!containerNode.__open) {\n          setDomHiddenUntilFound(dom)\n        }\n      })\n      domOnBeforeMatch(dom, () => {\n        editor.update(() => {\n          const containerNode = this.getParentOrThrow().getLatest()\n          invariant(\n            $isCollapsibleContainerNode(containerNode),\n            \"Expected parent node to be a CollapsibleContainerNode\"\n          )\n          if (!containerNode.__open) {\n            containerNode.toggleOpen()\n          }\n        })\n      })\n    }\n    return dom\n  }\n\n  updateDOM(prevNode: CollapsibleContentNode, dom: HTMLElement): boolean {\n    return false\n  }\n\n  static importDOM(): DOMConversionMap | null {\n    return {\n      div: (domNode: HTMLElement) => {\n        if (!domNode.hasAttribute(\"data-lexical-collapsible-content\")) {\n          return null\n        }\n        return {\n          conversion: $convertCollapsibleContentElement,\n          priority: 2,\n        }\n      },\n    }\n  }\n\n  exportDOM(): DOMExportOutput {\n    const element = document.createElement(\"div\")\n    element.classList.add(\"pt-0\", \"pr-1\", \"pb-1\", \"pl-4\")\n    element.setAttribute(\"data-lexical-collapsible-content\", \"true\")\n    return { element }\n  }\n\n  static importJSON(\n    serializedNode: SerializedCollapsibleContentNode\n  ): CollapsibleContentNode {\n    return $createCollapsibleContentNode()\n  }\n\n  isShadowRoot(): boolean {\n    return true\n  }\n\n  exportJSON(): SerializedCollapsibleContentNode {\n    return {\n      ...super.exportJSON(),\n      type: \"collapsible-content\",\n      version: 1,\n    }\n  }\n}\n\nexport function $createCollapsibleContentNode(): CollapsibleContentNode {\n  return new CollapsibleContentNode()\n}\n\nexport function $isCollapsibleContentNode(\n  node: LexicalNode | null | undefined\n): node is CollapsibleContentNode {\n  return node instanceof CollapsibleContentNode\n}\n",
      "type": "registry:component",
      "target": "components/editor/nodes/collapsible-content-node.ts"
    },
    {
      "path": "registry/new-york-v4/editor/nodes/collapsible-title-node.ts",
      "content": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nimport {\n  $createParagraphNode,\n  $isElementNode,\n  DOMConversionMap,\n  DOMConversionOutput,\n  EditorConfig,\n  ElementNode,\n  LexicalEditor,\n  LexicalNode,\n  RangeSelection,\n  SerializedElementNode,\n} from \"lexical\"\n\nimport { $isCollapsibleContainerNode } from \"@/registry/new-york-v4/editor/nodes/collapsible-container-node\"\nimport { $isCollapsibleContentNode } from \"@/registry/new-york-v4/editor/nodes/collapsible-content-node\"\nimport { IS_CHROME } from \"@/registry/new-york-v4/editor/shared/environment\"\nimport { invariant } from \"@/registry/new-york-v4/editor/shared/invariant\"\n\ntype SerializedCollapsibleTitleNode = SerializedElementNode\n\nexport function $convertSummaryElement(\n  domNode: HTMLElement\n): DOMConversionOutput | null {\n  const node = $createCollapsibleTitleNode()\n  return {\n    node,\n  }\n}\n\nexport class CollapsibleTitleNode extends ElementNode {\n  static getType(): string {\n    return \"collapsible-title\"\n  }\n\n  static clone(node: CollapsibleTitleNode): CollapsibleTitleNode {\n    return new CollapsibleTitleNode(node.__key)\n  }\n\n  createDOM(config: EditorConfig, editor: LexicalEditor): HTMLElement {\n    const dom = document.createElement(\"summary\")\n    dom.classList.add(\"Collapsible__title\")\n    if (IS_CHROME) {\n      dom.addEventListener(\"click\", () => {\n        editor.update(() => {\n          const collapsibleContainer = this.getLatest().getParentOrThrow()\n          invariant(\n            $isCollapsibleContainerNode(collapsibleContainer),\n            \"Expected parent node to be a CollapsibleContainerNode\"\n          )\n          collapsibleContainer.toggleOpen()\n        })\n      })\n    }\n    return dom\n  }\n\n  updateDOM(prevNode: CollapsibleTitleNode, dom: HTMLElement): boolean {\n    return false\n  }\n\n  static importDOM(): DOMConversionMap | null {\n    return {\n      summary: (domNode: HTMLElement) => {\n        return {\n          conversion: $convertSummaryElement,\n          priority: 1,\n        }\n      },\n    }\n  }\n\n  static importJSON(\n    serializedNode: SerializedCollapsibleTitleNode\n  ): CollapsibleTitleNode {\n    return $createCollapsibleTitleNode()\n  }\n\n  exportJSON(): SerializedCollapsibleTitleNode {\n    return {\n      ...super.exportJSON(),\n      type: \"collapsible-title\",\n      version: 1,\n    }\n  }\n\n  collapseAtStart(_selection: RangeSelection): boolean {\n    this.getParentOrThrow().insertBefore(this)\n    return true\n  }\n\n  static transform(): (node: LexicalNode) => void {\n    return (node: LexicalNode) => {\n      invariant(\n        $isCollapsibleTitleNode(node),\n        \"node is not a CollapsibleTitleNode\"\n      )\n      if (node.isEmpty()) {\n        node.remove()\n      }\n    }\n  }\n\n  insertNewAfter(_: RangeSelection, restoreSelection = true): ElementNode {\n    const containerNode = this.getParentOrThrow()\n\n    if (!$isCollapsibleContainerNode(containerNode)) {\n      throw new Error(\n        \"CollapsibleTitleNode expects to be child of CollapsibleContainerNode\"\n      )\n    }\n\n    if (containerNode.getOpen()) {\n      const contentNode = this.getNextSibling()\n      if (!$isCollapsibleContentNode(contentNode)) {\n        throw new Error(\n          \"CollapsibleTitleNode expects to have CollapsibleContentNode sibling\"\n        )\n      }\n\n      const firstChild = contentNode.getFirstChild()\n      if ($isElementNode(firstChild)) {\n        return firstChild\n      } else {\n        const paragraph = $createParagraphNode()\n        contentNode.append(paragraph)\n        return paragraph\n      }\n    } else {\n      const paragraph = $createParagraphNode()\n      containerNode.insertAfter(paragraph, restoreSelection)\n      return paragraph\n    }\n  }\n}\n\nexport function $createCollapsibleTitleNode(): CollapsibleTitleNode {\n  return new CollapsibleTitleNode()\n}\n\nexport function $isCollapsibleTitleNode(\n  node: LexicalNode | null | undefined\n): node is CollapsibleTitleNode {\n  return node instanceof CollapsibleTitleNode\n}\n",
      "type": "registry:component",
      "target": "components/editor/nodes/collapsible-title-node.ts"
    },
    {
      "path": "registry/new-york-v4/editor/plugins/toolbar/block-insert/insert-collapsible-container.tsx",
      "content": "\"use client\"\n\nimport { ChevronRightIcon } from \"lucide-react\"\n\nimport { useToolbarContext } from \"@/registry/new-york-v4/editor/context/toolbar-context\"\nimport { INSERT_COLLAPSIBLE_COMMAND } from \"@/registry/new-york-v4/editor/plugins/collapsible-plugin\"\nimport { SelectItem } from \"@/registry/new-york-v4/ui/select\"\n\nexport function InsertCollapsibleContainer() {\n  const { activeEditor } = useToolbarContext()\n  return (\n    <SelectItem\n      value=\"collapsible\"\n      onPointerUp={() =>\n        activeEditor.dispatchCommand(INSERT_COLLAPSIBLE_COMMAND, undefined)\n      }\n      className=\"\"\n    >\n      <div className=\"flex items-center gap-1\">\n        <ChevronRightIcon className=\"size-4\" />\n        <span>Collapsible container</span>\n      </div>\n    </SelectItem>\n  )\n}\n",
      "type": "registry:component",
      "target": "components/editor/plugins/toolbar/block-insert/insert-collapsible-container.tsx"
    }
  ]
}