{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "layout-plugin",
  "type": "registry:ui",
  "author": "shadcn (https://ui.shadcn.com)",
  "files": [
    {
      "path": "editor/plugins/layout-plugin.tsx",
      "content": "'use client'\r\n\r\n/**\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n */\r\nimport * as React from 'react'\r\nimport { useState, useEffect, JSX } from 'react'\r\n\r\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext'\r\nimport {\r\n  $findMatchingParent,\r\n  $insertNodeToNearestRoot,\r\n  mergeRegister,\r\n} from '@lexical/utils'\r\nimport { LexicalEditor } from 'lexical'\r\nimport type { ElementNode, LexicalCommand, LexicalNode, NodeKey } from 'lexical'\r\nimport {\r\n  $createParagraphNode,\r\n  $getNodeByKey,\r\n  $getSelection,\r\n  $isRangeSelection,\r\n  COMMAND_PRIORITY_EDITOR,\r\n  COMMAND_PRIORITY_LOW,\r\n  KEY_ARROW_DOWN_COMMAND,\r\n  KEY_ARROW_LEFT_COMMAND,\r\n  KEY_ARROW_RIGHT_COMMAND,\r\n  KEY_ARROW_UP_COMMAND,\r\n  createCommand,\r\n} from 'lexical'\r\n\r\nimport { Button } from '@/registry/default/ui/button'\r\nimport {\r\n  Select,\r\n  SelectContent,\r\n  SelectItem,\r\n  SelectTrigger,\r\n  SelectValue,\r\n} from '@/registry/default/ui/select'\r\n\r\nimport {\r\n  $createLayoutContainerNode,\r\n  $isLayoutContainerNode,\r\n  LayoutContainerNode,\r\n} from '@/registry/default/editor/nodes/layout-container-node'\r\nimport {\r\n  $createLayoutItemNode,\r\n  $isLayoutItemNode,\r\n  LayoutItemNode,\r\n} from '@/registry/default/editor/nodes/layout-item-node'\r\n\r\nconst LAYOUTS = [\r\n  { label: '2 columns (equal width)', value: '1fr 1fr' },\r\n  { label: '2 columns (25% - 75%)', value: '1fr 3fr' },\r\n  { label: '3 columns (equal width)', value: '1fr 1fr 1fr' },\r\n  { label: '3 columns (25% - 50% - 25%)', value: '1fr 2fr 1fr' },\r\n  { label: '4 columns (equal width)', value: '1fr 1fr 1fr 1fr' },\r\n]\r\n\r\nexport function InsertLayoutDialog({\r\n  activeEditor,\r\n  onClose,\r\n}: {\r\n  activeEditor: LexicalEditor\r\n  onClose: () => void\r\n}): JSX.Element {\r\n  const [layout, setLayout] = useState(LAYOUTS[0].value)\r\n  const buttonLabel = LAYOUTS.find((item) => item.value === layout)?.label\r\n\r\n  const onClick = () => {\r\n    activeEditor.dispatchCommand(INSERT_LAYOUT_COMMAND, layout)\r\n    onClose()\r\n  }\r\n\r\n  return (\r\n    <>\r\n      <Select onValueChange={setLayout} defaultValue={layout}>\r\n        <SelectTrigger className=\"w-full\">\r\n          <SelectValue placeholder={buttonLabel} />\r\n        </SelectTrigger>\r\n        <SelectContent className=\"w-full\">\r\n          {LAYOUTS.map(({ label, value }) => (\r\n            <SelectItem key={value} value={value}>\r\n              {label}\r\n            </SelectItem>\r\n          ))}\r\n        </SelectContent>\r\n      </Select>\r\n      <Button onClick={onClick}>Insert</Button>\r\n    </>\r\n  )\r\n}\r\n\r\nexport const INSERT_LAYOUT_COMMAND: LexicalCommand<string> =\r\n  createCommand<string>()\r\n\r\nexport const UPDATE_LAYOUT_COMMAND: LexicalCommand<{\r\n  template: string\r\n  nodeKey: NodeKey\r\n}> = createCommand<{ template: string; nodeKey: NodeKey }>()\r\n\r\nexport function LayoutPlugin(): null {\r\n  const [editor] = useLexicalComposerContext()\r\n  useEffect(() => {\r\n    if (!editor.hasNodes([LayoutContainerNode, LayoutItemNode])) {\r\n      throw new Error(\r\n        'LayoutPlugin: LayoutContainerNode, or LayoutItemNode not registered on editor'\r\n      )\r\n    }\r\n\r\n    const $onEscape = (before: boolean) => {\r\n      const selection = $getSelection()\r\n      if (\r\n        $isRangeSelection(selection) &&\r\n        selection.isCollapsed() &&\r\n        selection.anchor.offset === 0\r\n      ) {\r\n        const container = $findMatchingParent(\r\n          selection.anchor.getNode(),\r\n          $isLayoutContainerNode\r\n        )\r\n\r\n        if ($isLayoutContainerNode(container)) {\r\n          const parent = container.getParent<ElementNode>()\r\n          const child =\r\n            parent &&\r\n            (before\r\n              ? parent.getFirstChild<LexicalNode>()\r\n              : parent?.getLastChild<LexicalNode>())\r\n          const descendant = before\r\n            ? container.getFirstDescendant<LexicalNode>()?.getKey()\r\n            : container.getLastDescendant<LexicalNode>()?.getKey()\r\n\r\n          if (\r\n            parent !== null &&\r\n            child === container &&\r\n            selection.anchor.key === descendant\r\n          ) {\r\n            if (before) {\r\n              container.insertBefore($createParagraphNode())\r\n            } else {\r\n              container.insertAfter($createParagraphNode())\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      return false\r\n    }\r\n\r\n    return mergeRegister(\r\n      // When layout is the last child pressing down/right arrow will insert paragraph\r\n      // below it to allow adding more content. It's similar what $insertBlockNode\r\n      // (mainly for decorators), except it'll always be possible to continue adding\r\n      // new content even if trailing paragraph is accidentally deleted\r\n      editor.registerCommand(\r\n        KEY_ARROW_DOWN_COMMAND,\r\n        () => $onEscape(false),\r\n        COMMAND_PRIORITY_LOW\r\n      ),\r\n      editor.registerCommand(\r\n        KEY_ARROW_RIGHT_COMMAND,\r\n        () => $onEscape(false),\r\n        COMMAND_PRIORITY_LOW\r\n      ),\r\n      // When layout is the first child pressing up/left arrow will insert paragraph\r\n      // above it to allow adding more content. It's similar what $insertBlockNode\r\n      // (mainly for decorators), except it'll always be possible to continue adding\r\n      // new content even if leading paragraph is accidentally deleted\r\n      editor.registerCommand(\r\n        KEY_ARROW_UP_COMMAND,\r\n        () => $onEscape(true),\r\n        COMMAND_PRIORITY_LOW\r\n      ),\r\n      editor.registerCommand(\r\n        KEY_ARROW_LEFT_COMMAND,\r\n        () => $onEscape(true),\r\n        COMMAND_PRIORITY_LOW\r\n      ),\r\n      editor.registerCommand(\r\n        INSERT_LAYOUT_COMMAND,\r\n        (template) => {\r\n          editor.update(() => {\r\n            const container = $createLayoutContainerNode(template)\r\n            const itemsCount = getItemsCountFromTemplate(template)\r\n\r\n            for (let i = 0; i < itemsCount; i++) {\r\n              container.append(\r\n                $createLayoutItemNode().append($createParagraphNode())\r\n              )\r\n            }\r\n\r\n            $insertNodeToNearestRoot(container)\r\n            container.selectStart()\r\n          })\r\n\r\n          return true\r\n        },\r\n        COMMAND_PRIORITY_EDITOR\r\n      ),\r\n      editor.registerCommand(\r\n        UPDATE_LAYOUT_COMMAND,\r\n        ({ template, nodeKey }) => {\r\n          editor.update(() => {\r\n            const container = $getNodeByKey<LexicalNode>(nodeKey)\r\n\r\n            if (!$isLayoutContainerNode(container)) {\r\n              return\r\n            }\r\n\r\n            const itemsCount = getItemsCountFromTemplate(template)\r\n            const prevItemsCount = getItemsCountFromTemplate(\r\n              container.getTemplateColumns()\r\n            )\r\n\r\n            // Add or remove extra columns if new template does not match existing one\r\n            if (itemsCount > prevItemsCount) {\r\n              for (let i = prevItemsCount; i < itemsCount; i++) {\r\n                container.append(\r\n                  $createLayoutItemNode().append($createParagraphNode())\r\n                )\r\n              }\r\n            } else if (itemsCount < prevItemsCount) {\r\n              for (let i = prevItemsCount - 1; i >= itemsCount; i--) {\r\n                const layoutItem = container.getChildAtIndex<LexicalNode>(i)\r\n\r\n                if ($isLayoutItemNode(layoutItem)) {\r\n                  layoutItem.remove()\r\n                }\r\n              }\r\n            }\r\n\r\n            container.setTemplateColumns(template)\r\n          })\r\n\r\n          return true\r\n        },\r\n        COMMAND_PRIORITY_EDITOR\r\n      ),\r\n      // Structure enforcing transformers for each node type. In case nesting structure is not\r\n      // \"Container > Item\" it'll unwrap nodes and convert it back\r\n      // to regular content.\r\n      editor.registerNodeTransform(LayoutItemNode, (node) => {\r\n        const parent = node.getParent<ElementNode>()\r\n        if (!$isLayoutContainerNode(parent)) {\r\n          const children = node.getChildren<LexicalNode>()\r\n          for (const child of children) {\r\n            node.insertBefore(child)\r\n          }\r\n          node.remove()\r\n        }\r\n      }),\r\n      editor.registerNodeTransform(LayoutContainerNode, (node) => {\r\n        const children = node.getChildren<LexicalNode>()\r\n        if (!children.every($isLayoutItemNode)) {\r\n          for (const child of children) {\r\n            node.insertBefore(child)\r\n          }\r\n          node.remove()\r\n        }\r\n      })\r\n    )\r\n  }, [editor])\r\n\r\n  return null\r\n}\r\n\r\nfunction getItemsCountFromTemplate(template: string): number {\r\n  return template.trim().split(/\\s+/).length\r\n}\r\n",
      "type": "registry:component",
      "target": "components/editor/plugins/layout-plugin.tsx"
    }
  ]
}